

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>causaldag.classes.dag &mdash; causaldag  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> causaldag
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../classes/index.html">Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/index.html">Utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure_learning/index.html">Structure Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rand/index.html">Random Graphs</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">causaldag</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>causaldag.classes.dag</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for causaldag.classes.dag</h1><div class="highlight"><pre>
<span></span><span class="c1"># Author: Chandler Squires</span>
<span class="sd">&quot;&quot;&quot;Base class for causal DAGs</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">itr</span>
<span class="kn">from</span> <span class="nn">causaldag.utils</span> <span class="k">import</span> <span class="n">core_utils</span>
<span class="kn">import</span> <span class="nn">operator</span> <span class="k">as</span> <span class="nn">op</span>
<span class="kn">from</span> <span class="nn">causaldag.classes.custom_types</span> <span class="k">import</span> <span class="n">Node</span><span class="p">,</span> <span class="n">DirectedEdge</span><span class="p">,</span> <span class="n">NodeSet</span><span class="p">,</span> <span class="n">warn_untested</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">FrozenSet</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">networkx.utils</span> <span class="k">import</span> <span class="n">UnionFind</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">ipdb</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">comb</span>


<span class="k">class</span> <span class="nc">CycleError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cycle</span> <span class="o">=</span> <span class="n">cycle</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;Adding arc(s) causes the cycle &#39;</span> <span class="o">+</span> <span class="n">path2str</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">path2str</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;-&gt;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">DAG</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for causal DAGs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">Set</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(),</span> <span class="n">arcs</span><span class="p">:</span> <span class="n">Set</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(),</span> <span class="n">dag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">_arcs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">_neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nbrs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">_parents</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_children</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">_children</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_children</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
            <span class="c1"># print(&#39;before call to add arcs from&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_arcs_from</span><span class="p">(</span><span class="n">arcs</span><span class="p">,</span> <span class="n">check_acyclic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DAG</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_nodes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_arcs</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">()</span>
        <span class="n">substrings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">parents_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]))</span>
                <span class="n">substrings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">|</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parents_str</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">substrings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">substrings</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="DAG.copy"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.copy.html#causaldag.classes.dag.DAG.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the current DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return DAG(nodes=self._nodes, arcs=self._arcs)</span>
        <span class="k">return</span> <span class="n">DAG</span><span class="p">(</span><span class="n">dag</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="DAG.rename_nodes"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.rename_nodes.html#causaldag.classes.dag.DAG.rename_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">rename_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename the nodes in this graph according to ``name_map``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name_map:</span>
<span class="sd">            A dictionary from the current name of each node to the desired name of each node.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(&#39;a&#39;, &#39;b&#39;), (&#39;b&#39;, &#39;c&#39;)})</span>
<span class="sd">        &gt;&gt;&gt; g2 = g.rename_nodes({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3})</span>
<span class="sd">        &gt;&gt;&gt; g2.arcs</span>
<span class="sd">        {(1, 2), (2, 3)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DAG</span><span class="p">(</span>
            <span class="n">nodes</span><span class="o">=</span><span class="p">{</span><span class="n">name_map</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">},</span>
            <span class="n">arcs</span><span class="o">=</span><span class="p">{(</span><span class="n">name_map</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">name_map</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">}</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DAG.induced_subgraph"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.induced_subgraph.html#causaldag.classes.dag.DAG.induced_subgraph">[docs]</a>    <span class="k">def</span> <span class="nf">induced_subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the induced subgraph over only ``nodes``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes:</span>
<span class="sd">            Set of nodes for the induced subgraph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DAG:</span>
<span class="sd">            Induced subgraph over ``nodes``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG(arcs={(1, 2), (2, 3), (1, 4)})</span>
<span class="sd">        &gt;&gt;&gt; d_induced = d.induced_subgraph({1, 2, 3})</span>
<span class="sd">        &gt;&gt;&gt; d_induced.arcs</span>
<span class="sd">        {(1, 2), (2, 3)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DAG</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">})</span></div>

    <span class="c1"># === PROPERTIES</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">arcs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">DirectedEdge</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_arcs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">defdict2dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parents</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">defdict2dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">defdict2dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">{</span><span class="nb">frozenset</span><span class="p">({</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">})</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">in_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_in_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_out_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">)</span> <span class="o">/</span> <span class="n">p</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="c1"># === NODE PROPERTIES</span>
<div class="viewcode-block" id="DAG.parents_of"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.parents_of.html#causaldag.classes.dag.DAG.parents_of">[docs]</a>    <span class="k">def</span> <span class="nf">parents_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">NodeSet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all nodes that are parents of the node or set of nodes ``nodes``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes</span>
<span class="sd">            A node or set of nodes.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        children_of, neighbors_of, markov_blanket_of</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.parents_of(2)</span>
<span class="sd">        {1}</span>
<span class="sd">        &gt;&gt;&gt; g.parents_of({2, 3})</span>
<span class="sd">        {1, 2}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">nodes</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="DAG.children_of"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.children_of.html#causaldag.classes.dag.DAG.children_of">[docs]</a>    <span class="k">def</span> <span class="nf">children_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">NodeSet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all nodes that are children of the node or set of nodes ``nodes``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes</span>
<span class="sd">            A node or set of nodes.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        parents_of, neighbors_of, markov_blanket_of</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.children_of(1)</span>
<span class="sd">        {2}</span>
<span class="sd">        &gt;&gt;&gt; g.children_of({1, 2})</span>
<span class="sd">        {2, 3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">nodes</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="DAG.neighbors_of"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.neighbors_of.html#causaldag.classes.dag.DAG.neighbors_of">[docs]</a>    <span class="k">def</span> <span class="nf">neighbors_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">NodeSet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all nodes that are adjacent to the node or set of nodes ``node``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes</span>
<span class="sd">            A node or set of nodes.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        parents_of, children_of, markov_blanket_of</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(0,1), (0,2)})</span>
<span class="sd">        &gt;&gt;&gt; g.neighbors_of(0)</span>
<span class="sd">        {1, 2}</span>
<span class="sd">        &gt;&gt;&gt; g.neighbors_of(2)</span>
<span class="sd">        {0}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">nodes</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="DAG.markov_blanket_of"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.markov_blanket_of.html#causaldag.classes.dag.DAG.markov_blanket_of">[docs]</a>    <span class="k">def</span> <span class="nf">markov_blanket_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Markov blanket of ``node``, i.e., the parents of the node, its children, and the parents of its children.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node:</span>
<span class="sd">            Node whose Markov blanket to return.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        parents_of, children_of, neighbors_of</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set:</span>
<span class="sd">            the Markov blanket of ``node``.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(0, 1), (1, 3), (2, 3), (3, 4})</span>
<span class="sd">        &gt;&gt;&gt; g.markov_blanket_of(1)</span>
<span class="sd">        {0, 2, 3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parents_of_children</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">]))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span>
            <span class="n">node</span><span class="p">]</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">|</span> <span class="n">parents_of_children</span> <span class="o">-</span> <span class="p">{</span><span class="n">node</span><span class="p">}</span></div>

    <span class="k">def</span> <span class="nf">is_ancestor_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anc</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">desc</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if ``anc`` is an ancestor of ``desc``</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        bool</span>
<span class="sd">            True if ``anc`` is an ancestor  of ``desc``</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.is_ancestor_of(1, 3)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; g.is_ancestor_of(3, 1)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">desc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">anc</span><span class="p">]</span> <span class="ow">or</span> <span class="n">desc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">descendants_of</span><span class="p">(</span><span class="n">anc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_descendants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descendants</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">descendants</span><span class="p">:</span>
                <span class="n">descendants</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_descendants</span><span class="p">(</span><span class="n">descendants</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>

<div class="viewcode-block" id="DAG.descendants_of"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.descendants_of.html#causaldag.classes.dag.DAG.descendants_of">[docs]</a>    <span class="k">def</span> <span class="nf">descendants_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">NodeSet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the descendants of ``node``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes:</span>
<span class="sd">            The node.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ancestors_of</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        Set[node]</span>
<span class="sd">            Return all nodes j such that there is a directed path from ``node`` to j.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.descendants_of(1)</span>
<span class="sd">        {2, 3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">descendants</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_descendants</span><span class="p">(</span><span class="n">descendants</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descendants_of</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">descendants</span></div>

    <span class="k">def</span> <span class="nf">_add_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ancestors</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">parent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ancestors</span><span class="p">:</span>
                <span class="n">ancestors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_ancestors</span><span class="p">(</span><span class="n">ancestors</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>

<div class="viewcode-block" id="DAG.ancestors_of"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.ancestors_of.html#causaldag.classes.dag.DAG.ancestors_of">[docs]</a>    <span class="k">def</span> <span class="nf">ancestors_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ancestors of ``nodes``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes:</span>
<span class="sd">            The node.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        descendants_of</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        Set[node]</span>
<span class="sd">            Return all nodes j such that there is a directed path from j to ``node``.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.ancestors_of(3)</span>
<span class="sd">        {1, 2, 3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ancestors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_ancestors</span><span class="p">(</span><span class="n">ancestors</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_of</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ancestors</span></div>

<div class="viewcode-block" id="DAG.incident_arcs"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.incident_arcs.html#causaldag.classes.dag.DAG.incident_arcs">[docs]</a>    <span class="k">def</span> <span class="nf">incident_arcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">DirectedEdge</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all arcs with ``node`` as either source or target.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node:</span>
<span class="sd">            The node.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        incoming_arcs, outgoing_arcs</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        Set[arc]</span>
<span class="sd">            Return all arcs i-&gt;j such that either i=``node`` of j=``node``.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.incident_arcs(2)</span>
<span class="sd">        {(1, 2), (2, 3)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">incident_arcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">incident_arcs</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">incident_arcs</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">incident_arcs</span></div>

<div class="viewcode-block" id="DAG.incoming_arcs"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.incoming_arcs.html#causaldag.classes.dag.DAG.incoming_arcs">[docs]</a>    <span class="k">def</span> <span class="nf">incoming_arcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">DirectedEdge</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all arcs with target ``node``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node:</span>
<span class="sd">            The node.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        incident_arcs, outgoing_arcs</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        Set[arc]</span>
<span class="sd">            Return all arcs of the form i-&gt;``node``.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.incoming_arcs(2)</span>
<span class="sd">        {(1, 2)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">incoming_arcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">incoming_arcs</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">incoming_arcs</span></div>

<div class="viewcode-block" id="DAG.outgoing_arcs"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.outgoing_arcs.html#causaldag.classes.dag.DAG.outgoing_arcs">[docs]</a>    <span class="k">def</span> <span class="nf">outgoing_arcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">DirectedEdge</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all arcs with source ``node``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node:</span>
<span class="sd">            The node.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        incident_arcs, incoming_arcs</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        Set[arc]</span>
<span class="sd">            Return all arcs of the form ``node``-&gt;j.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.outgoing_arcs(2)</span>
<span class="sd">        {(2, 3)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">outgoing_arcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">outgoing_arcs</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">outgoing_arcs</span></div>

<div class="viewcode-block" id="DAG.outdegree_of"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.outdegree_of.html#causaldag.classes.dag.DAG.outdegree_of">[docs]</a>    <span class="k">def</span> <span class="nf">outdegree_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the outdegree of ``node``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node:</span>
<span class="sd">            The node.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        indegree_of</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        int</span>
<span class="sd">            The number of children of ``node``.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.outdegree_of(1)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; g.outdegree_of(3)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">])</span></div>

<div class="viewcode-block" id="DAG.indegree_of"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.indegree_of.html#causaldag.classes.dag.DAG.indegree_of">[docs]</a>    <span class="k">def</span> <span class="nf">indegree_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the indegree of ``node``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node:</span>
<span class="sd">            The node.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        outdegree_of</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        int</span>
<span class="sd">            The number of parents of ``node``.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.indegree_of(1)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; g.indegree_of(2)</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">])</span></div>

    <span class="c1"># ==== ORDERS</span>
<div class="viewcode-block" id="DAG.topological_sort"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.topological_sort.html#causaldag.classes.dag.DAG.topological_sort">[docs]</a>    <span class="k">def</span> <span class="nf">topological_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a topological sort of the nodes in the graph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[Node]</span>
<span class="sd">            A topological sort of the nodes in a graph.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.topological_sort</span>
<span class="sd">        [1, 2, 3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">any_visited</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">}</span>
        <span class="n">curr_path_visited</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">}</span>
        <span class="n">curr_path</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">any_visited</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mark_children_visited</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">any_visited</span><span class="p">,</span> <span class="n">curr_path_visited</span><span class="p">,</span> <span class="n">curr_path</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">stack</span><span class="p">))</span></div>

<div class="viewcode-block" id="DAG.is_topological"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.is_topological.html#causaldag.classes.dag.DAG.is_topological">[docs]</a>    <span class="k">def</span> <span class="nf">is_topological</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that ``order`` is a topological order consistent with this DAG, i.e., if ``i``-&gt;``j`` in the DAG,</span>
<span class="sd">        then ``i`` comes before ``j`` in the order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order:</span>
<span class="sd">            the order to check.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (1, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.is_topological([1, 2, 3])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; g.is_topological([1, 3, 2])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; g.is_topological([2, 1, 3])</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node2ix</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">ix</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">order</span><span class="p">)}</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">node2ix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">node2ix</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="DAG.permutation_score"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.permutation_score.html#causaldag.classes.dag.DAG.permutation_score">[docs]</a>    <span class="k">def</span> <span class="nf">permutation_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of &quot;errors&quot; in ``order`` with respect to the DAG, i.e., the number of times that ``i``-&gt;``j``</span>
<span class="sd">        in the DAG but ``i`` comes *after* ``j`` in ``order``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order:</span>
<span class="sd">            the order to check.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (1, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.permutation_score([1, 2, 3])</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; g.permutation_score([2, 1, 3])</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; g.permutation_score([2, 3, 1])</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node2ix</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">ix</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">order</span><span class="p">)}</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">node2ix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">node2ix</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">)</span></div>

    <span class="c1"># === GRAPH MODIFICATION</span>
<div class="viewcode-block" id="DAG.add_node"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.add_node.html#causaldag.classes.dag.DAG.add_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add ``node`` to the DAG.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node:</span>
<span class="sd">            a hashable Python object</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add_nodes_from</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG()</span>
<span class="sd">        &gt;&gt;&gt; g.add_node(1)</span>
<span class="sd">        &gt;&gt;&gt; g.add_node(2)</span>
<span class="sd">        &gt;&gt;&gt; len(g.nodes)</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>

<div class="viewcode-block" id="DAG.add_nodes_from"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.add_nodes_from.html#causaldag.classes.dag.DAG.add_nodes_from">[docs]</a>    <span class="k">def</span> <span class="nf">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add nodes to the graph from the collection ``nodes``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes:</span>
<span class="sd">            collection of nodes to be added.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add_node</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG({1, 2})</span>
<span class="sd">        &gt;&gt;&gt; g.add_nodes_from({&#39;a&#39;, &#39;b&#39;})</span>
<span class="sd">        &gt;&gt;&gt; g.add_nodes_from(range(3, 6))</span>
<span class="sd">        &gt;&gt;&gt; g.nodes</span>
<span class="sd">        {1, 2, &#39;a&#39;, &#39;b&#39;, 3, 4, 5}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>

<div class="viewcode-block" id="DAG.remove_node"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.remove_node.html#causaldag.classes.dag.DAG.remove_node">[docs]</a>    <span class="k">def</span> <span class="nf">remove_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">ignore_error</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the node ``node`` from the graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node:</span>
<span class="sd">            node to be removed.</span>
<span class="sd">        ignore_error:</span>
<span class="sd">            if True, ignore the KeyError raised when node is not in the DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; g.remove_node(2)</span>
<span class="sd">        &gt;&gt;&gt; g.nodes</span>
<span class="sd">        {1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">=</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">node</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">node</span><span class="p">}</span>

        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ignore_error</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span></div>

<div class="viewcode-block" id="DAG.add_arc"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.add_arc.html#causaldag.classes.dag.DAG.add_arc">[docs]</a>    <span class="k">def</span> <span class="nf">add_arc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">check_acyclic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the arc ``i`` -&gt; ``j`` to the DAG</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i:</span>
<span class="sd">            source node of the arc</span>
<span class="sd">        j:</span>
<span class="sd">            target node of the arc</span>
<span class="sd">        check_acyclic:</span>
<span class="sd">            if True, check that the DAG remains acyclic after adding the edge.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add_arcs_from</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG({1, 2})</span>
<span class="sd">        &gt;&gt;&gt; g.add_arc(1, 2)</span>
<span class="sd">        &gt;&gt;&gt; g.arcs</span>
<span class="sd">        {(1, 2)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check_acyclic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_acyclic</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">CycleError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_arc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">e</span></div>

<div class="viewcode-block" id="DAG.add_arcs_from"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.add_arcs_from.html#causaldag.classes.dag.DAG.add_arcs_from">[docs]</a>    <span class="k">def</span> <span class="nf">add_arcs_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arcs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">],</span> <span class="n">check_acyclic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add arcs to the graph from the collection ``arcs``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arcs:</span>
<span class="sd">            collection of arcs to be added.</span>
<span class="sd">        check_acyclic:</span>
<span class="sd">            if True, check that the DAG remains acyclic after adding the edge.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add_arcs</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; g.add_arcs_from({(1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.arcs</span>
<span class="sd">        {(1, 2), (1, 3), (2, 3)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arcs</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="n">arcs</span> <span class="o">=</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">arcs</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arcs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">sources</span><span class="p">,</span> <span class="n">sinks</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">arcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sinks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">arcs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">arcs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check_acyclic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_acyclic</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">CycleError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">arcs</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_arc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">e</span></div>

<div class="viewcode-block" id="DAG.remove_arc"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.remove_arc.html#causaldag.classes.dag.DAG.remove_arc">[docs]</a>    <span class="k">def</span> <span class="nf">remove_arc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">ignore_error</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the arc ``i`` -&gt; ``j``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i:</span>
<span class="sd">            source of arc to be removed.</span>
<span class="sd">        j:</span>
<span class="sd">            target of arc to be removed.</span>
<span class="sd">        ignore_error:</span>
<span class="sd">            if True, ignore the KeyError raised when arc is not in the DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; g.remove_arc(1, 2)</span>
<span class="sd">        &gt;&gt;&gt; g.arcs</span>
<span class="sd">        set()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ignore_error</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span></div>

    <span class="k">def</span> <span class="nf">remove_arcs_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arcs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">ignore_error</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove each arc in ``arcs`` from the DAG.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arcs</span>
<span class="sd">            The arcs to be removed from the DAG.</span>
<span class="sd">        ignore_error:</span>
<span class="sd">            if True, ignore the KeyError raised when an arc is not in the DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (2, 3), (3, 4)})</span>
<span class="sd">        &gt;&gt;&gt; g.remove_arcs_from({(1, 2), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.arcs</span>
<span class="sd">        {(3, 4)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">arcs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_arc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ignore_error</span><span class="o">=</span><span class="n">ignore_error</span><span class="p">)</span>

<div class="viewcode-block" id="DAG.reverse_arc"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.reverse_arc.html#causaldag.classes.dag.DAG.reverse_arc">[docs]</a>    <span class="k">def</span> <span class="nf">reverse_arc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">ignore_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_acyclic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverse the arc ``i`` -&gt; ``j`` to ``i`` &lt;- ``j``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i:</span>
<span class="sd">            source of arc to be reversed.</span>
<span class="sd">        j:</span>
<span class="sd">            target of arc to be reversed.</span>
<span class="sd">        ignore_error:</span>
<span class="sd">            if True, ignore the KeyError raised when arc is not in the DAG.</span>
<span class="sd">        check_acyclic:</span>
<span class="sd">            if True, check that the DAG remains acyclic after adding the edge.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; g.reverse_arc(1, 2)</span>
<span class="sd">        &gt;&gt;&gt; g.arcs</span>
<span class="sd">        {(2, 1)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_arc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ignore_error</span><span class="o">=</span><span class="n">ignore_error</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_arc</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">check_acyclic</span><span class="o">=</span><span class="n">check_acyclic</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_check_acyclic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_mark_children_visited</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">any_visited</span><span class="p">,</span> <span class="n">curr_path_visited</span><span class="p">,</span> <span class="n">curr_path</span><span class="p">,</span> <span class="n">stack</span><span class="p">):</span>
        <span class="n">any_visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">curr_path_visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">curr_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">any_visited</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mark_children_visited</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">any_visited</span><span class="p">,</span> <span class="n">curr_path_visited</span><span class="p">,</span> <span class="n">curr_path</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">curr_path_visited</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="n">curr_path</span> <span class="o">+</span> <span class="p">[</span><span class="n">child</span><span class="p">]</span>
                <span class="k">raise</span> <span class="n">CycleError</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
        <span class="n">curr_path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">curr_path_visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="c1"># === GRAPH PROPERTIES</span>
<div class="viewcode-block" id="DAG.has_arc"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.has_arc.html#causaldag.classes.dag.DAG.has_arc">[docs]</a>    <span class="k">def</span> <span class="nf">has_arc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this DAG has an arc ``source`` -&gt; ``target``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source:</span>
<span class="sd">            Source node of arc.</span>
<span class="sd">        target:</span>
<span class="sd">            Target node of arc.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(0,1), (0,2)})</span>
<span class="sd">        &gt;&gt;&gt; g.has_arc(0, 1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; g.has_arc(1, 2)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span></div>

<div class="viewcode-block" id="DAG.sources"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.sources.html#causaldag.classes.dag.DAG.sources">[docs]</a>    <span class="k">def</span> <span class="nf">sources</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all nodes in the graph that have no parents.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        List[node]</span>
<span class="sd">            Nodes in the graph that have no parents.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.sources()</span>
<span class="sd">        {1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span></div>

<div class="viewcode-block" id="DAG.sinks"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.sinks.html#causaldag.classes.dag.DAG.sinks">[docs]</a>    <span class="k">def</span> <span class="nf">sinks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all nodes in the graph that have no children.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        List[node]</span>
<span class="sd">            Nodes in the graph that have no children.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.sinks()</span>
<span class="sd">        {3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span></div>

<div class="viewcode-block" id="DAG.reversible_arcs"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.reversible_arcs.html#causaldag.classes.dag.DAG.reversible_arcs">[docs]</a>    <span class="k">def</span> <span class="nf">reversible_arcs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">DirectedEdge</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all reversible (aka covered) arcs in the DAG.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        Set[arc]</span>
<span class="sd">            Return all reversible (aka covered) arcs in the DAG. An arc i -&gt; j is *covered* if the :math:`Pa(j) = Pa(i) \cup {i}`.</span>
<span class="sd">            Reversing a reversible arc results in a DAG in the same Markov equivalence class.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.reversible_arcs()</span>
<span class="sd">        {(1, 2), (2, 3)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reversible_arcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="p">{</span><span class="n">i</span><span class="p">}):</span>
                <span class="n">reversible_arcs</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">reversible_arcs</span></div>

<div class="viewcode-block" id="DAG.is_reversible"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.is_reversible.html#causaldag.classes.dag.DAG.is_reversible">[docs]</a>    <span class="k">def</span> <span class="nf">is_reversible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the arc ``i`` -&gt; ``j`` is reversible (aka covered), i.e., if :math:`pa(i) = pa(j) \setminus \{i\}`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i:</span>
<span class="sd">            source of the arc</span>
<span class="sd">        j:</span>
<span class="sd">            target of the arc</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        True if the arc is reversible, otherwise False.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.is_reversible(1, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; g.is_reversible(1, 3)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="p">{</span><span class="n">i</span><span class="p">}</span></div>

<div class="viewcode-block" id="DAG.arcs_in_vstructures"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.arcs_in_vstructures.html#causaldag.classes.dag.DAG.arcs_in_vstructures">[docs]</a>    <span class="k">def</span> <span class="nf">arcs_in_vstructures</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all arcs in the graph that participate in a v-structure.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        Set[arc]</span>
<span class="sd">            Return all arcs in the graph in a v-structure (aka an immorality). A v-structure is formed when i-&gt;j&lt;-k but</span>
<span class="sd">            there is no arc between i and k. Arcs that participate in a v-structure are identifiable from observational</span>
<span class="sd">            data.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.arcs_in_vstructures()</span>
<span class="sd">        {(1, 3), (2, 3))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">{</span><span class="n">i</span><span class="p">}}</span></div>

<div class="viewcode-block" id="DAG.vstructures"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.vstructures.html#causaldag.classes.dag.DAG.vstructures">[docs]</a>    <span class="k">def</span> <span class="nf">vstructures</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all v-structures in the graph, i.e., triples of the form (i, k, j) such that ``i``-&gt;k&lt;-``j`` and ``i``</span>
<span class="sd">        is not adjacent to ``j``.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        Set[Tuple]</span>
<span class="sd">            Return all triples in the graph in a v-structure (aka an immorality). A v-structure is formed when i-&gt;j&lt;-k but</span>
<span class="sd">            there is no arc between i and k. Arcs that participate in a v-structure are identifiable from observational</span>
<span class="sd">            data.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.vstructures()</span>
<span class="sd">        {(1, 3, 2)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vstructs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">itr</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">p2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">p1</span><span class="p">]:</span>
                    <span class="n">vstructs</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">vstructs</span></div>

<div class="viewcode-block" id="DAG.triples"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.triples.html#causaldag.classes.dag.DAG.triples">[docs]</a>    <span class="k">def</span> <span class="nf">triples</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all triples of the form (``i``, ``j``, ``k``) such that ``i`` and ``k`` are both adjacent to ``j``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Set[Tuple]</span>
<span class="sd">            Triples in the graph.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 3), (2, 3), (1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; g.triples()</span>
<span class="sd">        {frozenset({1, 3, 2})}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">|=</span> <span class="p">{</span><span class="nb">frozenset</span><span class="p">({</span><span class="n">n1</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">n2</span><span class="p">})</span> <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">itr</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="mi">2</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">t</span></div>

<div class="viewcode-block" id="DAG.upstream_most"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.upstream_most.html#causaldag.classes.dag.DAG.upstream_most">[docs]</a>    <span class="k">def</span> <span class="nf">upstream_most</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of nodes which in ``s`` which have no ancestors in ``s``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s:</span>
<span class="sd">            Set of nodes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The set of nodes in ``s`` with no ancestors in ``s``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_of</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">}</span></div>

    <span class="c1"># === COMPARISON</span>
<div class="viewcode-block" id="DAG.shd"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.shd.html#causaldag.classes.dag.DAG.shd">[docs]</a>    <span class="k">def</span> <span class="nf">shd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the structural Hamming distance between this DAG and the DAG ``other``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other:</span>
<span class="sd">            the DAG to which the SHD will be computed.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        int</span>
<span class="sd">            The structural Hamming distance between :math:`G_1` and :math:`G_2` is the minimum number of arc additions,</span>
<span class="sd">            deletions, and reversals required to transform :math:`G_1` into :math:`G_2` (and vice versa).</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g1 = cd.DAG(arcs={(1, 2), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g2 = cd.DAG(arcs={(2, 1), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g1.shd(g2)</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DAG</span><span class="p">):</span>
            <span class="n">self_arcs_reversed</span> <span class="o">=</span> <span class="p">{(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">}</span>
            <span class="n">other_arcs_reversed</span> <span class="o">=</span> <span class="p">{(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_arcs</span><span class="p">}</span>

            <span class="n">additions</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">-</span> <span class="n">self_arcs_reversed</span>
            <span class="n">deletions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">-</span> <span class="n">other_arcs_reversed</span>
            <span class="n">reversals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arcs</span> <span class="o">&amp;</span> <span class="n">other_arcs_reversed</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">additions</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">deletions</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">reversals</span><span class="p">)</span></div>

<div class="viewcode-block" id="DAG.shd_skeleton"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.shd_skeleton.html#causaldag.classes.dag.DAG.shd_skeleton">[docs]</a>    <span class="k">def</span> <span class="nf">shd_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the structure Hamming distance between the skeleton of this DAG and the skeleton of the graph ``other``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other:</span>
<span class="sd">            the DAG to which the SHD of the skeleton will be computed.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        int</span>
<span class="sd">            The structural Hamming distance between :math:`G_1` and :math:`G_2` is the minimum number of arc additions,</span>
<span class="sd">            deletions, and reversals required to transform :math:`G_1` into :math:`G_2` (and vice versa).</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g1 = cd.DAG(arcs={(1, 2), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g2 = cd.DAG(arcs={(2, 1), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g1.shd_skeleton(g2)</span>
<span class="sd">        0</span>

<span class="sd">        &gt;&gt;&gt; g1 = cd.DAG(arcs={(1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; g2 = cd.DAG(arcs={(1, 2), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g1.shd_skeleton(g2)</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">skeleton</span><span class="p">))</span></div>

<div class="viewcode-block" id="DAG.markov_equivalent"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.markov_equivalent.html#causaldag.classes.dag.DAG.markov_equivalent">[docs]</a>    <span class="k">def</span> <span class="nf">markov_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">interventions</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this DAG is (interventionally) Markov equivalent to the DAG ``other``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other:</span>
<span class="sd">            Another DAG.</span>
<span class="sd">        interventions:</span>
<span class="sd">            If not None, check whether the two DAGs are interventionally Markov equivalent under the interventions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d1 = cd.DAG(arcs={(0, 1), (1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; d2 = cd.DAG(arcs={(2, 1), (1, 0)})</span>
<span class="sd">        &gt;&gt;&gt; d3 = cd.DAG(arcs={(0, 1), (2, 1)})</span>
<span class="sd">        &gt;&gt;&gt; d4 = cd.DAG(arcs={(1, 0), (1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; d1.markov_equivalent(d2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; d2.markov_equivalent(d1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; d1.markov_equivalent(d3)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; d1.markov_equivalent(d2, [{2}])</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; d1.markov_equivalent(d4, [{2}])</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">interventions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpdag</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">cpdag</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interventional_cpdag</span><span class="p">(</span><span class="n">interventions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpdag</span><span class="p">())</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">interventional_cpdag</span><span class="p">(</span><span class="n">interventions</span><span class="p">,</span>
                                                                                                        <span class="n">other</span><span class="o">.</span><span class="n">cpdag</span><span class="p">())</span></div>

<div class="viewcode-block" id="DAG.is_imap"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.is_imap.html#causaldag.classes.dag.DAG.is_imap">[docs]</a>    <span class="k">def</span> <span class="nf">is_imap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this DAG is an IMAP of the DAG ``other``, i.e., all d-separation statements in this graph</span>
<span class="sd">        are also d-separation statements in ``other``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other:</span>
<span class="sd">            Another DAG.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        is_minimal_imap</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if ``other`` is an I-MAP of this DAG, otherwise False.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (3, 2)})</span>
<span class="sd">        &gt;&gt;&gt; other = cd.DAG(arcs={(1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; g.is_imap(other)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; other = cd.DAG(arcs={(1, 2), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.is_imap(other)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dsep</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">nondesc</span><span class="p">,</span> <span class="n">parents</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">nondesc</span><span class="p">,</span> <span class="n">parents</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_markov_statements</span><span class="p">())</span></div>

<div class="viewcode-block" id="DAG.is_minimal_imap"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.is_minimal_imap.html#causaldag.classes.dag.DAG.is_minimal_imap">[docs]</a>    <span class="k">def</span> <span class="nf">is_minimal_imap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">certify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_imap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this DAG is a minimal IMAP of `other`, i.e., it is an IMAP and no proper subgraph of this DAG</span>
<span class="sd">        is an IMAP of other. Deleting the arc i-&gt;j retains IMAPness when `i` is d-separated from `j` in `other`</span>
<span class="sd">        given the parents of `j` besides `i` in this DAG.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other:</span>
<span class="sd">            Another DAG.</span>
<span class="sd">        certify:</span>
<span class="sd">            If True and this DAG is not an IMAP of other, return a certificate of non-minimality in the form</span>
<span class="sd">            of an edge i-&gt;j that can be deleted while retaining IMAPness.</span>
<span class="sd">        check_imap:</span>
<span class="sd">            If True, first check whether this DAG is an IMAP of other, if False, this DAG is assumed to be an IMAP</span>
<span class="sd">            of other.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        is_imap</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if ``other`` is a minimal I-MAP of this DAG, otherwise False.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (3, 2)})</span>
<span class="sd">        &gt;&gt;&gt; other = cd.DAG(arcs={(1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; g.is_minimal_imap(other)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">check_imap</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_imap</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">certify</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="n">certificate</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">dsep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="p">{</span><span class="n">i</span><span class="p">})),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">certify</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">certificate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="n">certificate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">certificate</span> <span class="ow">is</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="DAG.chickering_distance"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.chickering_distance.html#causaldag.classes.dag.DAG.chickering_distance">[docs]</a>    <span class="k">def</span> <span class="nf">chickering_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total number of edge reversals plus twice the number of edge additions/deletions required</span>
<span class="sd">        to turn this DAG into the DAG ``other``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other:</span>
<span class="sd">            the DAG against which to compare the Chickering distance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The Chickering distance between this DAG and the DAG ``other``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d1 = cd.DAG(arcs={(0, 1), (1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; d2 = cd.DAG(arcs={(0, 1), (2, 1), (3, 1)})</span>
<span class="sd">        &gt;&gt;&gt; d1.chickering_distance(d2)</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reversals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">&amp;</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">arc</span><span class="p">))</span> <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_arcs</span><span class="p">}</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">reversals</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">shd_skeleton</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="DAG.confusion_matrix"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.confusion_matrix.html#causaldag.classes.dag.DAG.confusion_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">confusion_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">rates_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the &quot;confusion matrix&quot; associated with estimating the CPDAG of ``other`` instead of the CPDAG of this DAG.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other:</span>
<span class="sd">            The DAG against which to compare.</span>
<span class="sd">        rates_only:</span>
<span class="sd">            if True, the dictionary of results only contains the false positive rate, true positive rate, and precision.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary of results</span>

<span class="sd">            * false_positive_arcs:</span>
<span class="sd">                the arcs in the CPDAG of ``other`` which are not arcs or edges in the CPDAG of this DAG.</span>
<span class="sd">            * false_positive_edges:</span>
<span class="sd">                the edges in the CPDAG of ``other`` which are not arcs or edges in the CPDAG of this DAG.</span>
<span class="sd">            * false_negative_arcs:</span>
<span class="sd">                the arcs in the CPDAG of this graph which are not arcs or edges in the CPDAG of ``other``.</span>
<span class="sd">            * true_positive_arcs:</span>
<span class="sd">                the arcs in the CPDAG of ``other`` which are arcs in the CPDAG of this DAG.</span>
<span class="sd">            * reversed_arcs:</span>
<span class="sd">                the arcs in the CPDAG of ``other`` whose reversals are arcs in the CPDAG of this DAG.</span>
<span class="sd">            * mistaken_arcs_for_edges:</span>
<span class="sd">                the arcs in the CPDAG of ``other`` whose reversals are arcs in the CPDAG of this DAG.</span>
<span class="sd">            * false_negative_edges:</span>
<span class="sd">                the edges in the CPDAG of this DAG which are not arcs or edges in the CPDAG of ``other``.</span>
<span class="sd">            * true_positive_edges:</span>
<span class="sd">                the edges in the CPDAG of ``other`` which are edges in the CPDAG of this DAG.</span>
<span class="sd">            * mistaken_edges_for_arcs:</span>
<span class="sd">                the edges in the CPDAG of ``other`` which are arcs in the CPDAG of this DAG.</span>
<span class="sd">            * num_false_positives:</span>
<span class="sd">                the total number of: false_positive_arcs, false_positive_edges</span>
<span class="sd">            * num_false_negatives:</span>
<span class="sd">                the total number of: false_negative_arcs, false_negative_edges, mistaken_arcs_for_edges, and reversed_arcs</span>
<span class="sd">            * num_true_positives:</span>
<span class="sd">                the total number of: true_positive_arcs, true_positive_edges, and mistaken_edges_for_arcs</span>
<span class="sd">            * num_true_negatives:</span>
<span class="sd">                the total number of missing arcs/edges in ``other`` which are actually missing in this DAG.</span>
<span class="sd">            * fpr:</span>
<span class="sd">                the false positive rate, i.e., num_false_positives/(num_false_positives+num_true_negatives). If this DAG</span>
<span class="sd">                is fully connected, defaults to 0.</span>
<span class="sd">            * tpr:</span>
<span class="sd">                the true positive rate, i.e., num_true_positives/(num_true_positives+num_false_negatives). If this DAG</span>
<span class="sd">                is empty, defaults to 1.</span>
<span class="sd">            * precision:</span>
<span class="sd">                the precision, i.e., num_true_positives/(num_true_positives+num_false_positives). If ``other`` is</span>
<span class="sd">                empty, defaults to 1.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d1 = cd.DAG(arcs={(0, 1), (1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; d2 = cd.DAG(arcs={(0, 1), (2, 1)})</span>
<span class="sd">        &gt;&gt;&gt; cm = d1.confusion_matrix(d2)</span>
<span class="sd">        &gt;&gt;&gt; cm[&quot;mistaken_edges_for_arcs&quot;]</span>
<span class="sd">        {frozenset({0, 1}), frozenset({1, 2})},</span>
<span class="sd">        &gt;&gt;&gt; cm = d2.confusion_matrix(d1)</span>
<span class="sd">        &gt;&gt;&gt; cm[&quot;mistaken_arcs_for_edges&quot;]</span>
<span class="sd">        {(0, 1), (2, 1)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">self_cpdag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpdag</span><span class="p">()</span>

        <span class="kn">from</span> <span class="nn">causaldag.classes.pdag</span> <span class="k">import</span> <span class="n">PDAG</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PDAG</span><span class="p">):</span>
            <span class="n">other_cpdag</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_cpdag</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">cpdag</span><span class="p">()</span>

        <span class="c1"># HELPER SETS SELF</span>
        <span class="n">self_arcs_as_edges</span> <span class="o">=</span> <span class="p">{</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span> <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="n">self_cpdag</span><span class="o">.</span><span class="n">_arcs</span><span class="p">}</span>
        <span class="n">self_edges_as_arcs1</span> <span class="o">=</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">self_cpdag</span><span class="o">.</span><span class="n">_edges</span><span class="p">}</span>
        <span class="n">self_edges_as_arcs2</span> <span class="o">=</span> <span class="p">{(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">self_edges_as_arcs1</span><span class="p">}</span>

        <span class="c1"># HELPER SETS OTHER</span>
        <span class="n">other_arcs_reversed</span> <span class="o">=</span> <span class="p">{(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">other_cpdag</span><span class="o">.</span><span class="n">_arcs</span><span class="p">}</span>
        <span class="n">other_arcs_as_edges</span> <span class="o">=</span> <span class="p">{</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span> <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="n">other_cpdag</span><span class="o">.</span><span class="n">_arcs</span><span class="p">}</span>
        <span class="n">other_edges_as_arcs1</span> <span class="o">=</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">other_cpdag</span><span class="o">.</span><span class="n">_edges</span><span class="p">}</span>
        <span class="n">other_edges_as_arcs2</span> <span class="o">=</span> <span class="p">{(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">other_edges_as_arcs1</span><span class="p">}</span>

        <span class="c1"># MISSING IN TRUE GRAPH</span>
        <span class="n">false_positive_arcs</span> <span class="o">=</span> <span class="n">other_cpdag</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">-</span> <span class="n">self_cpdag</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">-</span> <span class="n">self_edges_as_arcs1</span> <span class="o">-</span> <span class="n">self_edges_as_arcs2</span>
        <span class="n">false_positive_edges</span> <span class="o">=</span> <span class="n">other_cpdag</span><span class="o">.</span><span class="n">_edges</span> <span class="o">-</span> <span class="n">self_cpdag</span><span class="o">.</span><span class="n">_edges</span> <span class="o">-</span> <span class="n">self_arcs_as_edges</span>

        <span class="c1"># ARC IN TRUE GRAPH</span>
        <span class="n">false_negative_arcs</span> <span class="o">=</span> <span class="n">self_cpdag</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">-</span> <span class="n">other_cpdag</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">-</span> <span class="n">other_edges_as_arcs1</span> <span class="o">-</span> <span class="n">other_edges_as_arcs2</span>
        <span class="n">true_positive_arcs</span> <span class="o">=</span> <span class="n">self_cpdag</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">&amp;</span> <span class="n">other_cpdag</span><span class="o">.</span><span class="n">_arcs</span>
        <span class="n">reversed_arcs</span> <span class="o">=</span> <span class="n">self_cpdag</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">&amp;</span> <span class="n">other_arcs_reversed</span>
        <span class="n">mistaken_arcs_for_edges</span> <span class="o">=</span> <span class="n">self_cpdag</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">other_edges_as_arcs1</span> <span class="o">|</span> <span class="n">other_edges_as_arcs2</span><span class="p">)</span>

        <span class="c1"># EDGE IN TRUE GRAPH</span>
        <span class="n">false_negative_edges</span> <span class="o">=</span> <span class="n">self_cpdag</span><span class="o">.</span><span class="n">_edges</span> <span class="o">-</span> <span class="n">other_cpdag</span><span class="o">.</span><span class="n">_edges</span> <span class="o">-</span> <span class="n">other_arcs_as_edges</span>
        <span class="n">true_positive_edges</span> <span class="o">=</span> <span class="n">self_cpdag</span><span class="o">.</span><span class="n">_edges</span> <span class="o">&amp;</span> <span class="n">other_cpdag</span><span class="o">.</span><span class="n">_edges</span>
        <span class="n">mistaken_edges_for_arcs</span> <span class="o">=</span> <span class="n">self_cpdag</span><span class="o">.</span><span class="n">_edges</span> <span class="o">&amp;</span> <span class="n">other_arcs_as_edges</span>

        <span class="c1"># COMBINED_RESULTS</span>
        <span class="n">num_false_positives</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_positive_edges</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_negative_arcs</span><span class="p">)</span>
        <span class="n">num_false_negatives</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_negative_arcs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_negative_edges</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">mistaken_arcs_for_edges</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">reversed_arcs</span><span class="p">)</span>
        <span class="n">num_true_positives</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_positive_edges</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_positive_arcs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">mistaken_edges_for_arcs</span><span class="p">)</span>
        <span class="n">num_true_negatives</span> <span class="o">=</span> <span class="n">comb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nnodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_false_positives</span> <span class="o">-</span> <span class="n">num_false_negatives</span> <span class="o">-</span> <span class="n">num_true_positives</span>

        <span class="c1"># RATES</span>
        <span class="n">num_negatives</span> <span class="o">=</span> <span class="n">comb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nnodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_arcs</span>
        <span class="n">num_positives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_arcs</span>
        <span class="n">num_returned_positives</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_true_positives</span> <span class="o">+</span> <span class="n">num_false_positives</span><span class="p">)</span>
        <span class="n">fpr</span> <span class="o">=</span> <span class="n">num_false_positives</span> <span class="o">/</span> <span class="n">num_negatives</span> <span class="k">if</span> <span class="n">num_negatives</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">tpr</span> <span class="o">=</span> <span class="n">num_true_positives</span> <span class="o">/</span> <span class="n">num_positives</span> <span class="k">if</span> <span class="n">num_positives</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">precision</span> <span class="o">=</span> <span class="n">num_true_positives</span> <span class="o">/</span> <span class="n">num_returned_positives</span> <span class="k">if</span> <span class="n">num_returned_positives</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">rates_only</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">fpr</span><span class="o">=</span><span class="n">fpr</span><span class="p">,</span>
                <span class="n">tpr</span><span class="o">=</span><span class="n">tpr</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="n">precision</span>
            <span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">false_positive_arcs</span><span class="o">=</span><span class="n">false_positive_arcs</span><span class="p">,</span>
            <span class="n">false_positive_edges</span><span class="o">=</span><span class="n">false_positive_edges</span><span class="p">,</span>
            <span class="n">false_negative_arcs</span><span class="o">=</span><span class="n">false_negative_arcs</span><span class="p">,</span>
            <span class="n">true_positive_arcs</span><span class="o">=</span><span class="n">true_positive_arcs</span><span class="p">,</span>
            <span class="n">reversed_arcs</span><span class="o">=</span><span class="n">reversed_arcs</span><span class="p">,</span>
            <span class="n">mistaken_arcs_for_edges</span><span class="o">=</span><span class="n">mistaken_arcs_for_edges</span><span class="p">,</span>
            <span class="n">false_negative_edges</span><span class="o">=</span><span class="n">false_negative_edges</span><span class="p">,</span>
            <span class="n">true_positive_edges</span><span class="o">=</span><span class="n">true_positive_edges</span><span class="p">,</span>
            <span class="n">mistaken_edges_for_arcs</span><span class="o">=</span><span class="n">mistaken_edges_for_arcs</span><span class="p">,</span>
            <span class="n">num_false_positives</span><span class="o">=</span><span class="n">num_false_positives</span><span class="p">,</span>
            <span class="n">num_false_negatives</span><span class="o">=</span><span class="n">num_false_negatives</span><span class="p">,</span>
            <span class="n">num_true_positives</span><span class="o">=</span><span class="n">num_true_positives</span><span class="p">,</span>
            <span class="n">num_true_negatives</span><span class="o">=</span><span class="n">num_true_negatives</span><span class="p">,</span>
            <span class="n">fpr</span><span class="o">=</span><span class="n">fpr</span><span class="p">,</span>
            <span class="n">tpr</span><span class="o">=</span><span class="n">tpr</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="DAG.confusion_matrix_skeleton"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.confusion_matrix_skeleton.html#causaldag.classes.dag.DAG.confusion_matrix_skeleton">[docs]</a>    <span class="k">def</span> <span class="nf">confusion_matrix_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the &quot;confusion matrix&quot; associated with estimating the skeleton of ``other`` instead of the skeleton of</span>
<span class="sd">        this DAG.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other:</span>
<span class="sd">            The DAG against which to compare.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary of results</span>

<span class="sd">            * false_positives:</span>
<span class="sd">                the edges in the skeleton of ``other`` which are not in the skeleton of this DAG.</span>
<span class="sd">            * false_negatives:</span>
<span class="sd">                the edges in the skeleton of this graph which are not in the skeleton of ``other``.</span>
<span class="sd">            * true_positives:</span>
<span class="sd">                the edges in the skeleton of ``other`` which are acutally in the skeleton of this DAG.</span>
<span class="sd">            * num_false_positives:</span>
<span class="sd">                the total number of false_positives</span>
<span class="sd">            * num_false_negatives:</span>
<span class="sd">                the total number of false_negatives</span>
<span class="sd">            * num_true_positives:</span>
<span class="sd">                the total number of true_positives</span>
<span class="sd">            * num_true_negatives:</span>
<span class="sd">                the total number of missing edges in the skeleton of ``other`` which are actually missing in this DAG.</span>
<span class="sd">            * fpr:</span>
<span class="sd">                the false positive rate, i.e., num_false_positives/(num_false_positives+num_true_negatives). If this DAG</span>
<span class="sd">                is fully connected, defaults to 0.</span>
<span class="sd">            * tpr:</span>
<span class="sd">                the true positive rate, i.e., num_true_positives/(num_true_positives+num_false_negatives). If this DAG</span>
<span class="sd">                is empty, defaults to 1.</span>
<span class="sd">            * precision:</span>
<span class="sd">                the precision, i.e., num_true_positives/(num_true_positives+num_false_positives). If ``other`` is</span>
<span class="sd">                empty, defaults to 1.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d1 = cd.DAG(arcs={(0, 1), (1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; d2 = cd.DAG(arcs={(0, 1), (2, 1)})</span>
<span class="sd">        &gt;&gt;&gt; cm = d1.confusion_matrix_skeleton(d2)</span>
<span class="sd">        &gt;&gt;&gt; cm[&quot;tpr&quot;]</span>
<span class="sd">        1.0</span>
<span class="sd">        &gt;&gt;&gt; d3 = cd.DAG(arcs={(0, 1), (0, 2)})</span>
<span class="sd">        &gt;&gt;&gt; cm = d2.confusion_matrix_skeleton(d3)</span>
<span class="sd">        &gt;&gt;&gt; cm[&quot;true_positives&quot;]</span>
<span class="sd">        {frozenset({0, 1})}</span>
<span class="sd">        &gt;&gt;&gt; cm[&quot;false_positives&quot;]</span>
<span class="sd">        {frozenset({0, 2})},</span>
<span class="sd">        &gt;&gt;&gt; cm[&quot;false_negatives&quot;]</span>
<span class="sd">        {frozenset({1, 2})}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">self_skeleton</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span>
        <span class="n">other_skeleton</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">skeleton</span>

        <span class="n">true_positives</span> <span class="o">=</span> <span class="n">self_skeleton</span> <span class="o">&amp;</span> <span class="n">other_skeleton</span>
        <span class="n">false_positives</span> <span class="o">=</span> <span class="n">other_skeleton</span> <span class="o">-</span> <span class="n">self_skeleton</span>
        <span class="n">false_negatives</span> <span class="o">=</span> <span class="n">self_skeleton</span> <span class="o">-</span> <span class="n">other_skeleton</span>

        <span class="n">num_true_positives</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_positives</span><span class="p">)</span>
        <span class="n">num_false_positives</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_positives</span><span class="p">)</span>
        <span class="n">num_false_negatives</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">false_negatives</span><span class="p">)</span>
        <span class="n">num_true_negatives</span> <span class="o">=</span> <span class="n">comb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nnodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_true_positives</span> <span class="o">-</span> <span class="n">num_false_positives</span> <span class="o">-</span> <span class="n">num_false_negatives</span>

        <span class="n">num_positives</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">self_skeleton</span><span class="p">)</span>
        <span class="n">num_negatives</span> <span class="o">=</span> <span class="n">comb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nnodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_positives</span>

        <span class="n">tpr</span> <span class="o">=</span> <span class="n">num_true_positives</span> <span class="o">/</span> <span class="n">num_positives</span> <span class="k">if</span> <span class="n">num_positives</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">fpr</span> <span class="o">=</span> <span class="n">num_false_positives</span> <span class="o">/</span> <span class="n">num_negatives</span> <span class="k">if</span> <span class="n">num_negatives</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>

        <span class="n">res</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">true_positives</span><span class="o">=</span><span class="n">true_positives</span><span class="p">,</span>
            <span class="n">false_positives</span><span class="o">=</span><span class="n">false_positives</span><span class="p">,</span>
            <span class="n">false_negatives</span><span class="o">=</span><span class="n">false_negatives</span><span class="p">,</span>
            <span class="n">num_true_positives</span><span class="o">=</span><span class="n">num_true_positives</span><span class="p">,</span>
            <span class="n">num_false_positives</span><span class="o">=</span><span class="n">num_false_positives</span><span class="p">,</span>
            <span class="n">num_true_negatives</span><span class="o">=</span><span class="n">num_true_negatives</span><span class="p">,</span>
            <span class="n">num_false_negatives</span><span class="o">=</span><span class="n">num_false_negatives</span><span class="p">,</span>
            <span class="n">tpr</span><span class="o">=</span><span class="n">tpr</span><span class="p">,</span>
            <span class="n">fpr</span><span class="o">=</span><span class="n">fpr</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>

    <span class="c1"># === WRITING TO FILES</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_gml</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_csv</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">save_gml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="n">tab</span> <span class="o">=</span> <span class="s1">&#39;  &#39;</span>
        <span class="n">indent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">newline</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">indent</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">tab</span> <span class="o">*</span> <span class="n">indent</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;graph [&#39;</span><span class="p">)</span>
            <span class="n">indent</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">newline</span><span class="p">(</span><span class="n">indent</span><span class="p">))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;directed 1&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">newline</span><span class="p">(</span><span class="n">indent</span><span class="p">))</span>
            <span class="n">node2ix</span> <span class="o">=</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">ix_map_from_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">node2ix</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;node [&#39;</span><span class="p">)</span>
                <span class="n">indent</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">newline</span><span class="p">(</span><span class="n">indent</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;id </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">ix</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">newline</span><span class="p">(</span><span class="n">indent</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;label &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">node</span><span class="p">)</span>
                <span class="n">indent</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">newline</span><span class="p">(</span><span class="n">indent</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">newline</span><span class="p">(</span><span class="n">indent</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;edge [&#39;</span><span class="p">)</span>
                <span class="n">indent</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">newline</span><span class="p">(</span><span class="n">indent</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;source </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">source</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">newline</span><span class="p">(</span><span class="n">indent</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;target </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">target</span><span class="p">)</span>
                <span class="n">indent</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">newline</span><span class="p">(</span><span class="n">indent</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">newline</span><span class="p">(</span><span class="n">indent</span><span class="p">))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">:</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">])</span>

    <span class="c1"># === NUMPY CONVERSION</span>
<div class="viewcode-block" id="DAG.from_amat"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.from_amat.html#causaldag.classes.dag.DAG.from_amat">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_amat</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">amat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a DAG with arcs given by ``amat``, i.e. i-&gt;j if ``amat[i,j] != 0``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        amat:</span>
<span class="sd">            Numpy matrix representing arcs in the DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; amat = np.array([[0, 0, 1], [0, 0, 1], [0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG.from_amat(amat)</span>
<span class="sd">        &gt;&gt;&gt; d.arcs</span>
<span class="sd">        {(0, 2), (1, 2)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">amat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">arcs</span> <span class="o">=</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itr</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">DAG</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span> <span class="n">arcs</span><span class="o">=</span><span class="n">arcs</span><span class="p">)</span></div>

<div class="viewcode-block" id="DAG.to_amat"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.to_amat.html#causaldag.classes.dag.DAG.to_amat">[docs]</a>    <span class="k">def</span> <span class="nf">to_amat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an adjacency matrix for this DAG.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_list:</span>
<span class="sd">            List indexing the rows/columns of the matrix.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_amat</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        (amat, node_list)</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; g.to_amat()[0]</span>
<span class="sd">        array([[0, 1, 1],</span>
<span class="sd">               [0, 0, 1],</span>
<span class="sd">               [0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; g.to_amat()[1]</span>
<span class="sd">        [1, 2, 3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node_list</span><span class="p">:</span>
            <span class="n">node_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>
        <span class="n">node2ix</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_list</span><span class="p">)}</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">))</span>
        <span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">:</span>
            <span class="n">amat</span><span class="p">[</span><span class="n">node2ix</span><span class="p">[</span><span class="n">source</span><span class="p">],</span> <span class="n">node2ix</span><span class="p">[</span><span class="n">target</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">amat</span><span class="p">,</span> <span class="n">node_list</span></div>

    <span class="c1"># === NETWORKX CONVERSION</span>
<div class="viewcode-block" id="DAG.from_nx"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.from_nx.html#causaldag.classes.dag.DAG.from_nx">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_nx</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">nx_graph</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a networkx DiGraph into a DAG.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nx_graph:</span>
<span class="sd">            networkx DiGraph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DAG:</span>
<span class="sd">            The graph as a DAG object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">        &gt;&gt;&gt; g = nx.DiGraph()</span>
<span class="sd">        &gt;&gt;&gt; g.add_edges_from([(0, 1)])</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG.from_nx(g)</span>
<span class="sd">        &gt;&gt;&gt; d.arcs</span>
<span class="sd">        {(0, 1)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nx_graph</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must be a DiGraph&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DAG</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">nx_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="n">arcs</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">nx_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span></div>

<div class="viewcode-block" id="DAG.to_nx"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.to_nx.html#causaldag.classes.dag.DAG.to_nx">[docs]</a>    <span class="k">def</span> <span class="nf">to_nx</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert DAG to a networkx DiGraph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        networkx.DiGraph:</span>
<span class="sd">            The graph as a networkx.DiGraph object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG(arcs={(0, 1)})</span>
<span class="sd">        &gt;&gt;&gt; g = d.to_nx()</span>
<span class="sd">        &gt;&gt;&gt; g.edges</span>
<span class="sd">        OutEdgeView([(0, 1)])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span></div>

    <span class="c1"># === PANDAS CONVERSION</span>
<div class="viewcode-block" id="DAG.from_dataframe"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.from_dataframe.html#causaldag.classes.dag.DAG.from_dataframe">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dataframe</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a DAG from a dataframe, where the indices and columns are node names and a nonzero entry indicates</span>
<span class="sd">        the presence of an edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df:</span>
<span class="sd">            The pandas dataframe.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DAG:</span>
<span class="sd">            The graph as a DAG object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; amat = np.array([[0, 1], [0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(amat, index=[&quot;a&quot;, &quot;b&quot;], columns=[&quot;a&quot;, &quot;b&quot;])</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG.from_dataframe(df)</span>
<span class="sd">        &gt;&gt;&gt; d.arcs</span>
<span class="sd">        {(&#39;a&#39;, &#39;b&#39;)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">add_arc</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">g</span></div>

<div class="viewcode-block" id="DAG.to_dataframe"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.to_dataframe.html#causaldag.classes.dag.DAG.to_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turn this DAG into a dataframe, where the indices and columns are node names and a nonzero entry indicates</span>
<span class="sd">        the presence of an edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_list:</span>
<span class="sd">            Order to use when creating the dataframe. If None, uses a sorted order.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame:</span>
<span class="sd">            The graph as a DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG(arcs={(0, 1)})</span>
<span class="sd">        &gt;&gt;&gt; d.to_dataframe()</span>
<span class="sd">           0  1</span>
<span class="sd">        0  0  1</span>
<span class="sd">        1  0  0</span>
<span class="sd">        &gt;&gt;&gt; d.to_dataframe(node_list=[1, 0])</span>
<span class="sd">           1  0</span>
<span class="sd">        1  0  0</span>
<span class="sd">        0  1  0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">node_list</span><span class="p">:</span>
            <span class="n">node_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>
        <span class="n">node2ix</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_list</span><span class="p">)}</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">))</span>
        <span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">:</span>
            <span class="n">amat</span><span class="p">[</span><span class="n">node2ix</span><span class="p">[</span><span class="n">source</span><span class="p">],</span> <span class="n">node2ix</span><span class="p">[</span><span class="n">target</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">amat</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">node_list</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">node_list</span><span class="p">)</span></div>

    <span class="c1"># === SCIPY CONVERSION</span>
    <span class="k">def</span> <span class="nf">to_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># === SEPARATIONS</span>
<div class="viewcode-block" id="DAG.dsep"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.dsep.html#causaldag.classes.dag.DAG.dsep">[docs]</a>    <span class="k">def</span> <span class="nf">dsep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">Node</span><span class="p">],</span> <span class="n">B</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">Node</span><span class="p">],</span> <span class="n">C</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span>
             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">certify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if ``A`` and ``B`` are d-separated given ``C``, using the Bayes ball algorithm.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A:</span>
<span class="sd">            First set of nodes.</span>
<span class="sd">        B:</span>
<span class="sd">            Second set of nodes.</span>
<span class="sd">        C:</span>
<span class="sd">            Separating set of nodes.</span>
<span class="sd">        verbose:</span>
<span class="sd">            If True, print moves of the algorithm.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dsep_from_given</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        is_dsep</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (3, 2)})</span>
<span class="sd">        &gt;&gt;&gt; g.dsep(1, 3)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; g.dsep(1, 3, 2)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="c1"># type coercion</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">to_set</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">to_set</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">to_set</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

        <span class="c1"># shade ancestors of C</span>
        <span class="n">shaded_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_ancestors</span><span class="p">(</span><span class="n">shaded_nodes</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># marks for which direction the path is traveling through the node</span>
        <span class="n">_c</span> <span class="o">=</span> <span class="s1">&#39;_c&#39;</span>  <span class="c1"># child</span>
        <span class="n">_p</span> <span class="o">=</span> <span class="s1">&#39;_p&#39;</span>  <span class="c1"># parent</span>

        <span class="n">schedule</span> <span class="o">=</span> <span class="p">{(</span><span class="n">node</span><span class="p">,</span> <span class="n">_c</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">A</span><span class="p">}</span>
        <span class="k">while</span> <span class="n">schedule</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Current schedule:&#39;</span><span class="p">,</span> <span class="n">schedule</span><span class="p">)</span>

            <span class="n">node</span><span class="p">,</span> <span class="n">_dir</span> <span class="o">=</span> <span class="n">schedule</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">B</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">certify</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">B</span> <span class="ow">and</span> <span class="n">certify</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">node</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_dir</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">_dir</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Going through node&#39;</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="s1">&#39;in direction&#39;</span><span class="p">,</span> <span class="n">_dir</span><span class="p">)</span>

            <span class="c1"># if coming from child, won&#39;t encounter v-structure</span>
            <span class="k">if</span> <span class="n">_dir</span> <span class="o">==</span> <span class="n">_c</span> <span class="ow">and</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span>
                <span class="n">schedule</span><span class="o">.</span><span class="n">update</span><span class="p">({(</span><span class="n">parent</span><span class="p">,</span> <span class="n">_c</span><span class="p">)</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]})</span>
                <span class="n">schedule</span><span class="o">.</span><span class="n">update</span><span class="p">({(</span><span class="n">child</span><span class="p">,</span> <span class="n">_p</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">]})</span>

            <span class="k">if</span> <span class="n">_dir</span> <span class="o">==</span> <span class="n">_p</span><span class="p">:</span>
                <span class="c1"># if coming from parent and see shaded node, can go through v-structure</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">shaded_nodes</span><span class="p">:</span>
                    <span class="n">schedule</span><span class="o">.</span><span class="n">update</span><span class="p">({(</span><span class="n">parent</span><span class="p">,</span> <span class="n">_c</span><span class="p">)</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]})</span>

                <span class="c1"># if coming from parent and see unconditioned node, can go through children</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span>
                    <span class="n">schedule</span><span class="o">.</span><span class="n">update</span><span class="p">({(</span><span class="n">child</span><span class="p">,</span> <span class="n">_p</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">]})</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="DAG.dsep_from_given"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.dsep_from_given.html#causaldag.classes.dag.DAG.dsep_from_given">[docs]</a>    <span class="k">def</span> <span class="nf">dsep_from_given</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">NodeSet</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all nodes d-separated from ``A`` given ``C``.</span>

<span class="sd">        Uses algorithm in Geiger, D., Verma, T., &amp; Pearl, J. (1990).</span>
<span class="sd">        Identifying independence in Bayesian networks. Networks, 20(5), 507-534.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A:</span>
<span class="sd">            set of nodes.</span>
<span class="sd">        C:</span>
<span class="sd">            set of conditioned nodes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set</span>
<span class="sd">            Nodes which are d-separated from ``A`` given ``C``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG(arcs={(0, 1), (1, 2), (2, 3), (3, 4)})</span>
<span class="sd">        &gt;&gt;&gt; d.dsep_from_given(0, 1)</span>
<span class="sd">        {2, 3, 4]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">to_set</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">to_set</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

        <span class="n">determined</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">descendants</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span>
            <span class="n">determined</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">descendants</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_ancestors</span><span class="p">(</span><span class="n">descendants</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="n">reachable</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">i_links</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">labeled_links</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
            <span class="n">i_links</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
            <span class="n">reachable</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">i_p_1_links</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="c1"># Find all unlabled links v-&gt;w adjacent to at least one link u-&gt;v labeled i, such that (u-&gt;v,v-&gt;w) is a legal pair.</span>
            <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">i_links</span><span class="p">:</span>
                <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">link</span>
                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neighbors</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">u</span> <span class="o">==</span> <span class="n">w</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labeled_links</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>  <span class="c1"># Is collider?</span>
                            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">descendants</span><span class="p">:</span>
                                <span class="n">i_p_1_links</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
                                <span class="n">reachable</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Not collider</span>
                            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">determined</span><span class="p">:</span>
                                <span class="n">i_p_1_links</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
                                <span class="n">reachable</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_p_1_links</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">labeled_links</span> <span class="o">=</span> <span class="n">labeled_links</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">i_links</span><span class="p">)</span>
            <span class="n">i_links</span> <span class="o">=</span> <span class="n">i_p_1_links</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">reachable</span><span class="p">)</span></div>

<div class="viewcode-block" id="DAG.is_invariant"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.is_invariant.html#causaldag.classes.dag.DAG.is_invariant">[docs]</a>    <span class="k">def</span> <span class="nf">is_invariant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">intervened_nodes</span><span class="p">,</span> <span class="n">cond_set</span><span class="o">=</span><span class="nb">set</span><span class="p">(),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the distribution of ``A`` given cond_set is invariant to an intervention on intervened_nodes.</span>

<span class="sd">        :math:`f^\emptyset(A|C) = f^I(A|C)` if the &quot;intervention node&quot; I with intervened_nodes as its children</span>
<span class="sd">        is d-separated from A given C. Equivalently, the :math:`f^\emptyset(A|C) \neq f^I(A|C)` if:</span>

<span class="sd">        - there is an active path to an intervened node that ends in an arrowhead, and that intervened node</span>
<span class="sd">            or one of its descendants is conditioned on.</span>
<span class="sd">        - there is an active path to an intervened node that ends in a tail, and that intervened node</span>
<span class="sd">            is not conditioned on.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A:</span>
<span class="sd">            Set of nodes.</span>
<span class="sd">        intervened_nodes:</span>
<span class="sd">            Nodes on which an intervention has occurred.</span>
<span class="sd">        cond_set:</span>
<span class="sd">            Conditioning set for the tested distribution.</span>
<span class="sd">        verbose:</span>
<span class="sd">            If True, print moves of the algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="c1"># type coercion</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">to_set</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">to_set</span><span class="p">(</span><span class="n">intervened_nodes</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">to_set</span><span class="p">(</span><span class="n">cond_set</span><span class="p">)</span>

        <span class="c1"># shade ancestors of C</span>
        <span class="n">shaded_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_ancestors</span><span class="p">(</span><span class="n">shaded_nodes</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># marks for which direction the path is traveling through the node</span>
        <span class="n">_c</span> <span class="o">=</span> <span class="s1">&#39;_c&#39;</span>  <span class="c1"># child</span>
        <span class="n">_p</span> <span class="o">=</span> <span class="s1">&#39;_p&#39;</span>  <span class="c1"># parent</span>

        <span class="n">schedule</span> <span class="o">=</span> <span class="p">{(</span><span class="n">node</span><span class="p">,</span> <span class="n">_c</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">A</span><span class="p">}</span>
        <span class="k">while</span> <span class="n">schedule</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Current schedule:&#39;</span><span class="p">,</span> <span class="n">schedule</span><span class="p">)</span>

            <span class="n">node</span><span class="p">,</span> <span class="n">_dir</span> <span class="o">=</span> <span class="n">schedule</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">I</span> <span class="ow">and</span> <span class="n">_dir</span> <span class="o">==</span> <span class="n">_p</span> <span class="ow">and</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">shaded_nodes</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">I</span> <span class="ow">and</span> <span class="n">_dir</span> <span class="o">==</span> <span class="n">_c</span> <span class="ow">and</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_dir</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">_dir</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Going through node&#39;</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="s1">&#39;in direction&#39;</span><span class="p">,</span> <span class="n">_dir</span><span class="p">)</span>

            <span class="c1"># if coming from child, won&#39;t encounter v-structure</span>
            <span class="k">if</span> <span class="n">_dir</span> <span class="o">==</span> <span class="n">_c</span> <span class="ow">and</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span>
                <span class="n">schedule</span><span class="o">.</span><span class="n">update</span><span class="p">({(</span><span class="n">parent</span><span class="p">,</span> <span class="n">_c</span><span class="p">)</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]})</span>
                <span class="n">schedule</span><span class="o">.</span><span class="n">update</span><span class="p">({(</span><span class="n">child</span><span class="p">,</span> <span class="n">_p</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">]})</span>

            <span class="k">if</span> <span class="n">_dir</span> <span class="o">==</span> <span class="n">_p</span><span class="p">:</span>
                <span class="c1"># if coming from parent and see shaded node, can go through v-structure</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">shaded_nodes</span><span class="p">:</span>
                    <span class="n">schedule</span><span class="o">.</span><span class="n">update</span><span class="p">({(</span><span class="n">parent</span><span class="p">,</span> <span class="n">_c</span><span class="p">)</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]})</span>

                <span class="c1"># if coming from parent and see unconditioned node, can go through children</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span>
                    <span class="n">schedule</span><span class="o">.</span><span class="n">update</span><span class="p">({(</span><span class="n">child</span><span class="p">,</span> <span class="n">_p</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">]})</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="DAG.local_markov_statements"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.local_markov_statements.html#causaldag.classes.dag.DAG.local_markov_statements">[docs]</a>    <span class="k">def</span> <span class="nf">local_markov_statements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">FrozenSet</span><span class="p">,</span> <span class="n">FrozenSet</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the local Markov statements of this DAG, i.e., those of the form ``i`` independent nondescendants(i) given</span>
<span class="sd">        the parents of ``i``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set</span>
<span class="sd">            The set of tuples of the form (``i``, ``A``, ``C``) representing the local Markov statements of the DAG</span>
<span class="sd">            via (``i`` independent of ``A`` given ``C``).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (3, 2)})</span>
<span class="sd">        &gt;&gt;&gt; g.local_markov_statements()</span>
<span class="sd">        {(1, frozenset({3}), frozenset()), (2, frozenset(), frozenset({1, 3})), (3, frozenset({1}), frozenset())}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">statements</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">:</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="n">nondescendants</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">-</span> <span class="p">{</span><span class="n">node</span><span class="p">}</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">descendants_of</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">-</span> <span class="n">parents</span>
            <span class="n">statements</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">nondescendants</span><span class="p">),</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">parents</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">statements</span></div>

    <span class="c1"># === CONVERSION TO OTHER GRAPHS</span>
<div class="viewcode-block" id="DAG.moral_graph"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.moral_graph.html#causaldag.classes.dag.DAG.moral_graph">[docs]</a>    <span class="k">def</span> <span class="nf">moral_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (undirected) moral graph of this DAG, i.e., the graph with the parents of all nodes made adjacent.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        UndirectedGraph:</span>
<span class="sd">            Moral graph of this DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG(arcs={(1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; ug = d.moral_graph()</span>
<span class="sd">        &gt;&gt;&gt; ug.edges</span>
<span class="sd">        {frozenset({1, 3}), frozenset({2, 3}), frozenset({1, 2})}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="kn">from</span> <span class="nn">causaldag</span> <span class="k">import</span> <span class="n">UndirectedGraph</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">}</span> <span class="o">|</span> <span class="p">{(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vstructures</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">UndirectedGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="DAG.marginal_mag"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.marginal_mag.html#causaldag.classes.dag.DAG.marginal_mag">[docs]</a>    <span class="k">def</span> <span class="nf">marginal_mag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latent_nodes</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the maximal ancestral graph (MAG) that results from marginalizing out ``latent_nodes``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        latent_nodes:</span>
<span class="sd">            nodes to marginalize over.</span>
<span class="sd">        relabel:</span>
<span class="sd">            if relabel=&#39;default&#39;, relabel the nodes to have labels 1,2,...,(#nodes).</span>
<span class="sd">        new:</span>
<span class="sd">            TODO - pick whether to use new or old implementation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        m:</span>
<span class="sd">            cd.AncestralGraph, the MAG resulting from marginalizing out `latent_nodes`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG(arcs={(1, 3), (1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; mag = d.marginal_mag(latent_nodes={1})</span>
<span class="sd">        &gt;&gt;&gt; mag</span>
<span class="sd">        Directed edges: set(), Bidirected edges: {frozenset({2, 3})}, Undirected edges: set()</span>
<span class="sd">        &gt;&gt;&gt; mag = d.marginal_mag(latent_nodes={1}, relabel=&quot;default&quot;)</span>
<span class="sd">        Directed edges: set(), Bidirected edges: {frozenset({0, 1})}, Undirected edges: set()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="kn">from</span> <span class="nn">.ancestral_graph</span> <span class="k">import</span> <span class="n">AncestralGraph</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">new</span><span class="p">:</span>
            <span class="n">latent_nodes</span> <span class="o">=</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">to_set</span><span class="p">(</span><span class="n">latent_nodes</span><span class="p">)</span>

            <span class="n">new_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">-</span> <span class="n">latent_nodes</span>
            <span class="n">directed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">bidirected</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itr</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">-</span> <span class="n">latent_nodes</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">adjacent</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dsep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="k">for</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">powerset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">-</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">}</span> <span class="o">-</span> <span class="n">latent_nodes</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">adjacent</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ancestor_of</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                        <span class="n">directed</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ancestor_of</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                        <span class="n">directed</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">bidirected</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">relabel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">()</span>
                <span class="n">t_new</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">latent_nodes</span><span class="p">]</span>
                <span class="n">node2new_label</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">reversed</span><span class="p">,</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t_new</span><span class="p">)))</span>
                <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">node2new_label</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">new_nodes</span><span class="p">}</span>
                <span class="n">directed</span> <span class="o">=</span> <span class="p">{(</span><span class="n">node2new_label</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">node2new_label</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">directed</span><span class="p">}</span>
                <span class="n">bidirected</span> <span class="o">=</span> <span class="p">{(</span><span class="n">node2new_label</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">node2new_label</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bidirected</span><span class="p">}</span>

            <span class="k">return</span> <span class="n">AncestralGraph</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">new_nodes</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">,</span> <span class="n">bidirected</span><span class="o">=</span><span class="n">bidirected</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ag = AncestralGraph(nodes=self._nodes, directed=self._arcs)</span>
            <span class="c1"># curr_directed = ag.directed</span>
            <span class="c1"># curr_bidirected = ag.bidirected</span>
            <span class="c1">#</span>
            <span class="c1"># while True:</span>
            <span class="c1">#     for node in latent_nodes:</span>
            <span class="c1">#         parents = ag._parents[node]</span>
            <span class="c1">#         children = ag._children[node]</span>
            <span class="c1">#         spouses = ag._spouses[node]</span>
            <span class="c1">#         for j, i in itr.product(parents, children):</span>
            <span class="c1">#             ag._add_directed(j, i, ignore_error=True)</span>
            <span class="c1">#         for i, j in itr.combinations(children, 2):</span>
            <span class="c1">#             ag._add_bidirected(i, j, ignore_error=True)</span>
            <span class="c1">#         for i, j in itr.product(children, spouses):</span>
            <span class="c1">#             ag._add_bidirected(i, j, ignore_error=True)</span>
            <span class="c1">#</span>
            <span class="c1">#     last_directed = curr_directed</span>
            <span class="c1">#     last_bidirected = curr_bidirected</span>
            <span class="c1">#     curr_directed = ag.directed</span>
            <span class="c1">#     curr_bidirected = ag.bidirected</span>
            <span class="c1">#     if curr_directed == last_directed and curr_bidirected == last_bidirected:</span>
            <span class="c1">#         break</span>
            <span class="c1"># for node in latent_nodes:</span>
            <span class="c1">#     ag.remove_node(node, ignore_error=True)</span>

            <span class="n">ag</span> <span class="o">=</span> <span class="n">AncestralGraph</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">)</span>
            <span class="n">ancestor_dict</span> <span class="o">=</span> <span class="n">ag</span><span class="o">.</span><span class="n">ancestor_dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itr</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">-</span> <span class="n">latent_nodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="n">ancestor_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="n">ancestor_dict</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">-</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">}</span> <span class="o">-</span> <span class="n">latent_nodes</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ag</span><span class="o">.</span><span class="n">has_any_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ag</span><span class="o">.</span><span class="n">msep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ancestor_dict</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">ag</span><span class="o">.</span><span class="n">_add_directed</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ancestor_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">ag</span><span class="o">.</span><span class="n">_add_directed</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ag</span><span class="o">.</span><span class="n">_add_bidirected</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">latent_nodes</span><span class="p">:</span>
                <span class="n">ag</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ignore_error</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">relabel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">relabel</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
                    <span class="n">relabel</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">ix</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">latent_nodes</span><span class="p">)))}</span>
                <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">relabel</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">latent_nodes</span><span class="p">)}</span>
                <span class="n">directed</span> <span class="o">=</span> <span class="p">{(</span><span class="n">relabel</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">relabel</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ag</span><span class="o">.</span><span class="n">directed</span><span class="p">}</span>
                <span class="n">bidirected</span> <span class="o">=</span> <span class="p">{(</span><span class="n">relabel</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">relabel</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ag</span><span class="o">.</span><span class="n">bidirected</span><span class="p">}</span>
                <span class="k">return</span> <span class="n">AncestralGraph</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">,</span> <span class="n">bidirected</span><span class="o">=</span><span class="n">bidirected</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">ag</span></div>

<div class="viewcode-block" id="DAG.cpdag"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.cpdag.html#causaldag.classes.dag.DAG.cpdag">[docs]</a>    <span class="k">def</span> <span class="nf">cpdag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the completed partially directed acyclic graph (CPDAG, aka essential graph) that represents the</span>
<span class="sd">        Markov equivalence class of this DAG.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        causaldag.PDAG:</span>
<span class="sd">            CPDAG representing the MEC of this DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (2, 4), (3, 4)})</span>
<span class="sd">        &gt;&gt;&gt; cpdag = g.cpdag()</span>
<span class="sd">        &gt;&gt;&gt; cpdag.edges</span>
<span class="sd">        {frozenset({1, 2})}</span>
<span class="sd">        &gt;&gt;&gt; cpdag.arcs</span>
<span class="sd">        {(2, 4), (3, 4)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">causaldag</span> <span class="k">import</span> <span class="n">PDAG</span>
        <span class="n">pdag</span> <span class="o">=</span> <span class="n">PDAG</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">,</span> <span class="n">arcs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">,</span> <span class="n">known_arcs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">arcs_in_vstructures</span><span class="p">())</span>
        <span class="n">pdag</span><span class="o">.</span><span class="n">remove_unprotected_orientations</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pdag</span></div>

    <span class="k">def</span> <span class="nf">cpdag_new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">causaldag</span> <span class="k">import</span> <span class="n">PDAG</span>
        <span class="n">vstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arcs_in_vstructures</span><span class="p">()</span>
        <span class="n">pdag</span> <span class="o">=</span> <span class="n">PDAG</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">,</span> <span class="n">arcs</span><span class="o">=</span><span class="n">vstruct</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">-</span> <span class="n">vstruct</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new</span><span class="p">:</span>
            <span class="n">pdag</span><span class="o">.</span><span class="n">to_complete_pdag_new</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pdag</span><span class="o">.</span><span class="n">to_complete_pdag</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pdag</span>

<div class="viewcode-block" id="DAG.interventional_cpdag"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.interventional_cpdag.html#causaldag.classes.dag.DAG.interventional_cpdag">[docs]</a>    <span class="k">def</span> <span class="nf">interventional_cpdag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interventions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">set</span><span class="p">],</span> <span class="n">cpdag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the interventional essential graph (aka CPDAG) associated with this DAG.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        interventions:</span>
<span class="sd">            A list of the intervention targets.</span>
<span class="sd">        cpdag:</span>
<span class="sd">            The original (non-interventional) CPDAG of the graph. Faster when provided.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        causaldag.PDAG:</span>
<span class="sd">            Interventional CPDAG representing the I-MEC of this DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; g = cd.DAG(arcs={(1, 2), (2, 4), (3, 4)})</span>
<span class="sd">        &gt;&gt;&gt; cpdag = g.cpdag()</span>
<span class="sd">        &gt;&gt;&gt; icpdag = g.interventional_cpdag([{1}], cpdag=cpdag)</span>
<span class="sd">        &gt;&gt;&gt; icpdag.arcs</span>
<span class="sd">        {(1, 2), (2, 4), (3, 4)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="kn">from</span> <span class="nn">causaldag</span> <span class="k">import</span> <span class="n">PDAG</span>

        <span class="k">if</span> <span class="n">cpdag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Need the CPDAG&#39;</span><span class="p">)</span>
            <span class="c1"># dag_cut = self.copy()</span>
            <span class="c1"># known_arcs = set()</span>
            <span class="c1"># for node in intervened_nodes:</span>
            <span class="c1">#     for i, j in dag_cut.incoming_arcs(node):</span>
            <span class="c1">#         dag_cut.remove_arc(i, j)</span>
            <span class="c1">#         known_arcs.update(self.outgoing_arcs(node))</span>
            <span class="c1"># known_arcs.update(dag_cut.vstructs())</span>
            <span class="c1"># pdag = PDAG(dag_cut._nodes, dag_cut._arcs, known_arcs=known_arcs)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cut_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">iv_nodes</span> <span class="ow">in</span> <span class="n">interventions</span><span class="p">:</span>
                <span class="n">cut_edges</span><span class="o">.</span><span class="n">update</span><span class="p">({(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">}</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">iv_nodes</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">})</span>
            <span class="n">known_arcs</span> <span class="o">=</span> <span class="n">cut_edges</span> <span class="o">|</span> <span class="n">cpdag</span><span class="o">.</span><span class="n">_known_arcs</span>
            <span class="n">pdag</span> <span class="o">=</span> <span class="n">PDAG</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">,</span> <span class="n">known_arcs</span><span class="o">=</span><span class="n">known_arcs</span><span class="p">)</span>

        <span class="n">pdag</span><span class="o">.</span><span class="n">remove_unprotected_orientations</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pdag</span></div>

    <span class="c1"># === CHICKERING SEQUENCE</span>
    <span class="k">def</span> <span class="nf">_is_resolved_sink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">res_sinks</span><span class="p">):</span>
        <span class="n">no_children</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">-</span> <span class="n">res_sinks</span><span class="p">)</span>
        <span class="n">no_children_other</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">-</span> <span class="n">res_sinks</span><span class="p">)</span>
        <span class="n">same_parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">no_children</span> <span class="ow">and</span> <span class="n">no_children_other</span> <span class="ow">and</span> <span class="n">same_parents</span>

<div class="viewcode-block" id="DAG.resolved_sinks"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.resolved_sinks.html#causaldag.classes.dag.DAG.resolved_sinks">[docs]</a>    <span class="k">def</span> <span class="nf">resolved_sinks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the nodes in this graph which are &quot;resolved sinks&quot; with respect to the graph ``other``.</span>

<span class="sd">        A &quot;resolved sink&quot; is a node which has the same parents in both graphs, and no children which are</span>
<span class="sd">        not themselves resolved sinks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            TODO</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d1 = cd.DAG(arcs={(1, 0), (1, 2), (2, 0)})</span>
<span class="sd">        &gt;&gt;&gt; d2 = cd.DAG(arcs={(2, 0), (2, 1), (1, 0)})</span>
<span class="sd">        &gt;&gt;&gt; res_sinks = d1.resolved_sinks(d2)</span>
<span class="sd">        {0}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="n">res_sinks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">new_resolved</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">-</span> <span class="n">res_sinks</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_resolved_sink</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">res_sinks</span><span class="p">)}</span>
            <span class="n">res_sinks</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_resolved</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">new_resolved</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">res_sinks</span></div>

<div class="viewcode-block" id="DAG.chickering_sequence"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.chickering_sequence.html#causaldag.classes.dag.DAG.chickering_sequence">[docs]</a>    <span class="k">def</span> <span class="nf">chickering_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imap</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a *Chickering sequence* from this DAG to an I-MAP ``imap``.</span>

<span class="sd">        A Chickering sequence from DAG ``D1`` to a DAG ``D2`` is a sequence of DAGs starting at ``D1`` and ending at</span>
<span class="sd">        ``D2``, with consecutive DAGs differing by a single edge reversal or edge deletion, such that each DAG is an</span>
<span class="sd">        IMAP of ``D1``.</span>

<span class="sd">        See Chickering, David Maxwell. &quot;Optimal structure identification with greedy search.&quot; (2002) for more details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        imap: DAG</span>
<span class="sd">            The I-MAP of this DAG at which the Chickering sequence will end.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d1 = cd.DAG(arcs={(0, 1), (1, 2)})</span>
<span class="sd">        &gt;&gt;&gt; d2 = cd.DAG(arcs={(2, 0), (2, 1), (1, 0)})</span>
<span class="sd">        &gt;&gt;&gt; sequence, moves = d1.chickering_sequence(d2)</span>
<span class="sd">        &gt;&gt;&gt; sequence[1].arcs</span>
<span class="sd">        {(1, 0), (1, 2)}</span>
<span class="sd">        &gt;&gt;&gt; sequence[2].arcs</span>
<span class="sd">        {(1, 0), (1, 2), (2, 0)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="n">curr_graph</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">ch_seq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">moves</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">last_sink</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="n">curr_graph</span> <span class="o">!=</span> <span class="n">imap</span><span class="p">:</span>
            <span class="n">ch_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_graph</span><span class="p">)</span>
            <span class="n">curr_graph</span><span class="p">,</span> <span class="n">last_sink</span><span class="p">,</span> <span class="n">move</span> <span class="o">=</span> <span class="n">curr_graph</span><span class="o">.</span><span class="n">apply_edge_operation</span><span class="p">(</span><span class="n">imap</span><span class="p">,</span> <span class="n">seed_sink</span><span class="o">=</span><span class="n">last_sink</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">moves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">move</span><span class="p">)</span>

        <span class="n">ch_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imap</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ch_seq</span><span class="p">,</span> <span class="n">moves</span></div>

<div class="viewcode-block" id="DAG.apply_edge_operation"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.apply_edge_operation.html#causaldag.classes.dag.DAG.apply_edge_operation">[docs]</a>    <span class="k">def</span> <span class="nf">apply_edge_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imap</span><span class="p">,</span> <span class="n">seed_sink</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify an edge operation (covered edge reversal or edge addition) which decreases the Chickering distance</span>
<span class="sd">        from this DAG to ``imap``.</span>

<span class="sd">        See Chickering, David Maxwell. &quot;Optimal structure identification with greedy search.&quot; (2002), Fig. 2 for</span>
<span class="sd">        more details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        imap:</span>
<span class="sd">            The target I-MAP.</span>
<span class="sd">        seed_sink:</span>
<span class="sd">            If the algorithm reaches step 3, pick this node (if it is indeed a valid sink).</span>
<span class="sd">        verbose:</span>
<span class="sd">            If ``True``, print out the steps of the algorithm.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (DAG, Node, int)</span>
<span class="sd">            * The updated DAG</span>
<span class="sd">            * The node picked for the operation</span>
<span class="sd">            * The type of the edge operation (corresponding to the line of the algorithm in the above paper)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="n">new_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># STEP 2: REMOVE RESOLVED SINKS</span>
        <span class="n">resolved_sinks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolved_sinks</span><span class="p">(</span><span class="n">imap</span><span class="p">)</span>
        <span class="n">self_subgraph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">induced_subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">-</span> <span class="n">resolved_sinks</span><span class="p">)</span>
        <span class="n">imap_subgraph</span> <span class="o">=</span> <span class="n">imap</span><span class="o">.</span><span class="n">induced_subgraph</span><span class="p">(</span><span class="n">imap</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">-</span> <span class="n">resolved_sinks</span><span class="p">)</span>

        <span class="c1"># STEP 3: PICK A SINK IN THE IMAP</span>
        <span class="n">imap_sinks</span> <span class="o">=</span> <span class="n">imap_subgraph</span><span class="o">.</span><span class="n">sinks</span><span class="p">()</span>
        <span class="n">sink</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">imap_sinks</span><span class="p">))</span> <span class="k">if</span> <span class="n">seed_sink</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">seed_sink</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">imap_sinks</span> <span class="k">else</span> <span class="n">seed_sink</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Step 3: Picked </span><span class="si">{sink}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># STEP 4: ADD A PARENT IF Y IS A SINK IN G</span>
        <span class="k">if</span> <span class="n">sink</span> <span class="ow">in</span> <span class="n">self_subgraph</span><span class="o">.</span><span class="n">sinks</span><span class="p">():</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">imap_subgraph</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">sink</span><span class="p">]</span> <span class="o">-</span> <span class="n">self_subgraph</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">sink</span><span class="p">]))</span>
            <span class="n">new_graph</span><span class="o">.</span><span class="n">add_arc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sink</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Step 4: Added </span><span class="si">{x}</span><span class="s2">-&gt;</span><span class="si">{sink}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_graph</span><span class="p">,</span> <span class="n">sink</span><span class="p">,</span> <span class="mi">4</span>

        <span class="c1"># STEP 5: PICK A SPECIFIC CHILD OF Y IN G</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">imap_subgraph</span><span class="o">.</span><span class="n">upstream_most</span><span class="p">(</span><span class="n">self_subgraph</span><span class="o">.</span><span class="n">descendants_of</span><span class="p">(</span><span class="n">sink</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">valid_children</span> <span class="o">=</span> <span class="n">self_subgraph</span><span class="o">.</span><span class="n">upstream_most</span><span class="p">(</span><span class="n">self_subgraph</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="n">sink</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span>
                <span class="n">self_subgraph</span><span class="o">.</span><span class="n">ancestors_of</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">|</span> <span class="p">{</span><span class="n">d</span><span class="p">})</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">valid_children</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Step 5: Picked z=</span><span class="si">{z}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># STEP 6</span>
        <span class="k">if</span> <span class="n">self_subgraph</span><span class="o">.</span><span class="n">is_reversible</span><span class="p">(</span><span class="n">sink</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="n">new_graph</span><span class="o">.</span><span class="n">reverse_arc</span><span class="p">(</span><span class="n">sink</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Step 6: Reversing </span><span class="si">{sink}</span><span class="s2">-&gt;</span><span class="si">{z}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_graph</span><span class="p">,</span> <span class="n">sink</span><span class="p">,</span> <span class="mi">6</span>

        <span class="c1"># STEP 7</span>
        <span class="n">par_z</span> <span class="o">=</span> <span class="n">self_subgraph</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="o">-</span> <span class="n">self_subgraph</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">sink</span><span class="p">]</span> <span class="o">-</span> <span class="p">{</span><span class="n">sink</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">par_z</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">par_z</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Step 7: Picked x=</span><span class="si">{x}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">new_graph</span><span class="o">.</span><span class="n">add_arc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sink</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Step 7: Adding </span><span class="si">{x}</span><span class="s2">-&gt;</span><span class="si">{sink}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_graph</span><span class="p">,</span> <span class="n">sink</span><span class="p">,</span> <span class="mi">7</span>

        <span class="c1"># STEP 8</span>
        <span class="n">par_sink</span> <span class="o">=</span> <span class="n">self_subgraph</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">sink</span><span class="p">]</span> <span class="o">-</span> <span class="n">self_subgraph</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">z</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">par_sink</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Step 8: Picked x=</span><span class="si">{x}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">new_graph</span><span class="o">.</span><span class="n">add_arc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Step 8: Adding </span><span class="si">{x}</span><span class="s2">-&gt;</span><span class="si">{z}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_graph</span><span class="p">,</span> <span class="n">sink</span><span class="p">,</span> <span class="mi">8</span></div>

    <span class="c1"># === DIRECTED CLIQUE TREES</span>
<div class="viewcode-block" id="DAG.directed_clique_tree"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.directed_clique_tree.html#causaldag.classes.dag.DAG.directed_clique_tree">[docs]</a>    <span class="k">def</span> <span class="nf">directed_clique_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the directed clique tree associated with this DAG.</span>

<span class="sd">        See the following for the definition of the directed clique tree:</span>
<span class="sd">        Squires, Chandler, et al. &quot;Active Structure Learning of Causal DAGs via Directed Clique Tree.&quot; (2020)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose</span>
<span class="sd">            if True, print out the steps taken to compute the directed clique tree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        networkx.MultiDiGraph</span>
<span class="sd">            The directed clique tree of this DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG(arcs={(0, 1), (1, 2), (1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; dct = d.directed_clique_tree()</span>
<span class="sd">        &gt;&gt;&gt; dct.nodes</span>
<span class="sd">        NodeView((frozenset({1, 2, 3}), frozenset({0, 1})))</span>
<span class="sd">        &gt;&gt;&gt; dct.edges</span>
<span class="sd">        OutMultiEdgeView([(frozenset({0, 1}), frozenset({1, 2, 3}), 0)])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="n">cliques</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">chordal_graph_cliques</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_nx</span><span class="p">()</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">())</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
        <span class="n">ct</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">cliques</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">):</span> <span class="n">c1</span> <span class="o">&amp;</span> <span class="n">c2</span> <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">itr</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">cliques</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">c1</span> <span class="o">&amp;</span> <span class="n">c2</span><span class="p">}</span>
        <span class="n">subtrees</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">()</span>
        <span class="n">bidirected_components</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Considering edge </span><span class="si">{c1}</span><span class="s2">-</span><span class="si">{c2}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subtrees</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">subtrees</span><span class="p">[</span><span class="n">c2</span><span class="p">]:</span>
                <span class="n">shared</span> <span class="o">=</span> <span class="n">c1</span> <span class="o">&amp;</span> <span class="n">c2</span>
                <span class="n">all_into_c1</span> <span class="o">=</span> <span class="nb">all</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">itr</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">shared</span><span class="p">,</span> <span class="n">c1</span> <span class="o">-</span> <span class="n">shared</span><span class="p">))</span>
                <span class="n">all_into_c2</span> <span class="o">=</span> <span class="nb">all</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">itr</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">shared</span><span class="p">,</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">shared</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">all_into_c1</span> <span class="ow">and</span> <span class="n">all_into_c2</span><span class="p">:</span>
                    <span class="n">c1_parent</span> <span class="o">=</span> <span class="n">bidirected_components</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span>
                    <span class="n">c2_parent</span> <span class="o">=</span> <span class="n">bidirected_components</span><span class="p">[</span><span class="n">c2</span><span class="p">]</span>
                    <span class="n">b1</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">bidirected_components</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">parent</span> <span class="o">==</span> <span class="n">c1_parent</span><span class="p">]</span>
                    <span class="n">b2</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">bidirected_components</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">parent</span> <span class="o">==</span> <span class="n">c2_parent</span><span class="p">]</span>
                    <span class="n">b1_source</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">)</span>
                    <span class="n">b2_source</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">b1_source</span> <span class="ow">and</span> <span class="n">b2_source</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Adding edge </span><span class="si">{c1}</span><span class="s2">&lt;-&gt;</span><span class="si">{c2}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">subtrees</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
                        <span class="n">bidirected_components</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
                        <span class="n">ct</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
                        <span class="n">ct</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">c1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="k">if</span> <span class="n">all_into_c2</span> <span class="k">else</span> <span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">c1</span><span class="p">)</span>
                    <span class="n">c2_parent</span> <span class="o">=</span> <span class="n">bidirected_components</span><span class="p">[</span><span class="n">c2</span><span class="p">]</span>
                    <span class="n">bidirected_component</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">c</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">bidirected_components</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">parent</span> <span class="o">==</span> <span class="n">c2_parent</span>
                    <span class="p">]</span>
                    <span class="n">has_source</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
                        <span class="nb">set</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bidirected_component</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">has_source</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{c1}</span><span class="s2">-&gt;</span><span class="si">{c2}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">ct</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
                        <span class="n">subtrees</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="p">{(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="n">c1</span> <span class="o">&amp;</span> <span class="n">c2</span> <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">ct</span><span class="o">.</span><span class="n">edges</span><span class="p">()}</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ct</span></div>

<div class="viewcode-block" id="DAG.contracted_directed_clique_tree"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.contracted_directed_clique_tree.html#causaldag.classes.dag.DAG.contracted_directed_clique_tree">[docs]</a>    <span class="k">def</span> <span class="nf">contracted_directed_clique_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the contracted directed clique tree associated with this DAG.</span>

<span class="sd">        See the following for the definition of the contracted directed clique tree:</span>
<span class="sd">        Squires, Chandler, et al. &quot;Active Structure Learning of Causal DAGs via Directed Clique Tree.&quot; (2020)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        networkx.MultiDiGraph</span>
<span class="sd">            The directed clique tree of this DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG(arcs={(0, 1), (1, 2), (1, 3), (1, 4), (3, 2), (3, 4)})</span>
<span class="sd">        &gt;&gt;&gt; cdct = d.contracted_directed_clique_tree()</span>
<span class="sd">        &gt;&gt;&gt; cdct.nodes</span>
<span class="sd">        NodeView((frozenset({frozenset({1, 2, 3}), frozenset({1, 3, 4})}), frozenset({frozenset({0, 1})})))</span>
<span class="sd">        &gt;&gt;&gt; cdct.edges</span>
<span class="sd">        OutEdgeView([(frozenset({frozenset({0, 1})}), frozenset({frozenset({1, 2, 3}), frozenset({1, 3, 4})}))])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="n">dct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directed_clique_tree</span><span class="p">()</span>

        <span class="c1"># find bidirected connected components</span>
        <span class="n">all_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dct</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
        <span class="n">bidirected_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">bidirected_graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">dct</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="n">bidirected_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">({(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">all_edges</span> <span class="k">if</span> <span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">all_edges</span><span class="p">})</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">bidirected_graph</span><span class="p">)]</span>
        <span class="n">clique2component</span> <span class="o">=</span> <span class="p">{</span><span class="n">clique</span><span class="p">:</span> <span class="n">component</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">components</span> <span class="k">for</span> <span class="n">clique</span> <span class="ow">in</span> <span class="n">component</span><span class="p">}</span>

        <span class="c1"># contract bidirected connected components</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">({</span>
            <span class="p">(</span><span class="n">clique2component</span><span class="p">[</span><span class="n">c1</span><span class="p">],</span> <span class="n">clique2component</span><span class="p">[</span><span class="n">c2</span><span class="p">])</span> <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">all_edges</span>
            <span class="k">if</span> <span class="n">clique2component</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">clique2component</span><span class="p">[</span><span class="n">c2</span><span class="p">]</span>
        <span class="p">})</span>

        <span class="k">return</span> <span class="n">g</span></div>

<div class="viewcode-block" id="DAG.residuals"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.residuals.html#causaldag.classes.dag.DAG.residuals">[docs]</a>    <span class="k">def</span> <span class="nf">residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the residuals associated with this DAG.</span>

<span class="sd">        See the following for the definition of residuals:</span>
<span class="sd">        Squires, Chandler, et al. &quot;Active Structure Learning of Causal DAGs via Directed Clique Tree.&quot; (2020)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        networkx.MultiDiGraph</span>
<span class="sd">            The directed clique tree of this DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG(arcs={(0, 1), (1, 2), (1, 3), (1, 4), (3, 2), (3, 4)})</span>
<span class="sd">        &gt;&gt;&gt; residuals = d.residuals()</span>
<span class="sd">        &gt;&gt;&gt; residuals</span>
<span class="sd">        [frozenset({2, 3, 4}), frozenset({0, 1})]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="n">sdct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contracted_directed_clique_tree</span><span class="p">()</span>
        <span class="n">sdct_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sdct</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">sdct_components</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">component</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">sdct_nodes</span><span class="p">]</span>
        <span class="n">sdct_parents</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">sdct</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">component</span><span class="p">))</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">sdct_nodes</span><span class="p">]</span>
        <span class="n">sdct_parents</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">p</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">sdct_parents</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">component</span> <span class="o">-</span> <span class="n">parent</span> <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">parent</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sdct_components</span><span class="p">,</span> <span class="n">sdct_parents</span><span class="p">)]</span></div>

<div class="viewcode-block" id="DAG.residual_essential_graph"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.residual_essential_graph.html#causaldag.classes.dag.DAG.residual_essential_graph">[docs]</a>    <span class="k">def</span> <span class="nf">residual_essential_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the residual essential graph associated with this DAG.</span>

<span class="sd">        See the following for the definition of the residual essential graph:</span>
<span class="sd">        Squires, Chandler, et al. &quot;Active Structure Learning of Causal DAGs via Directed Clique Tree.&quot; (2020)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        networkx.MultiDiGraph</span>
<span class="sd">            The directed clique tree of this DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG(arcs={(0, 1), (1, 2), (1, 3), (1, 4), (3, 2), (3, 4)})</span>
<span class="sd">        &gt;&gt;&gt; r_eg = d.residual_essential_graph()</span>
<span class="sd">        &gt;&gt;&gt; r_eg.arcs</span>
<span class="sd">        {(1, 2), (1, 3), (1, 4)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="kn">from</span> <span class="nn">causaldag</span> <span class="k">import</span> <span class="n">PDAG</span>

        <span class="n">sdct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contracted_directed_clique_tree</span><span class="p">()</span>
        <span class="n">sdct_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sdct</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">sdct_components</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">component</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">sdct_nodes</span><span class="p">]</span>
        <span class="n">sdct_parents</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">sdct</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">component</span><span class="p">))</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">sdct_nodes</span><span class="p">]</span>
        <span class="n">sdct_parents</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">p</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">sdct_parents</span><span class="p">]</span>
        <span class="n">sdct_residuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">component</span> <span class="o">-</span> <span class="n">parent</span> <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">parent</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sdct_components</span><span class="p">,</span> <span class="n">sdct_parents</span><span class="p">)]</span>
        <span class="n">arcs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">parent</span><span class="p">,</span> <span class="n">residual</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sdct_parents</span><span class="p">,</span> <span class="n">sdct_residuals</span><span class="p">,</span> <span class="n">sdct_components</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">itr</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">parent</span> <span class="o">&amp;</span> <span class="n">component</span><span class="p">,</span> <span class="n">residual</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">PDAG</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">,</span> <span class="n">arcs</span><span class="o">=</span><span class="n">arcs</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_arcs</span> <span class="o">-</span> <span class="n">arcs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span></div>

    <span class="c1"># === INTERVENTION DESIGN</span>
<div class="viewcode-block" id="DAG.optimal_fully_orienting_single_node_interventions"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.optimal_fully_orienting_single_node_interventions.html#causaldag.classes.dag.DAG.optimal_fully_orienting_single_node_interventions">[docs]</a>    <span class="k">def</span> <span class="nf">optimal_fully_orienting_single_node_interventions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cpdag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the smallest set of interventions which fully orients the CPDAG into this DAG.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cpdag</span>
<span class="sd">            the starting CPDAG containing known orientations. If None, compute and use the observational essential graph.</span>
<span class="sd">        new:</span>
<span class="sd">            TODO: remove after checking that directed clique tree method works.</span>
<span class="sd">        verbose:</span>
<span class="sd">            TODO: describe.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        interventions</span>
<span class="sd">            A minimum-size set of interventions which fully orients the DAG.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; import itertools as itr</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG(arcs=set(itr.combinations(range(5), 2)))</span>
<span class="sd">        &gt;&gt;&gt; ivs = d.optimal_fully_orienting_single_node_interventions()</span>
<span class="sd">        &gt;&gt;&gt; ivs</span>
<span class="sd">        {1, 3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new</span><span class="p">:</span>
            <span class="n">sdct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contracted_directed_clique_tree</span><span class="p">()</span>
            <span class="n">top_sort</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span><span class="n">sdct</span><span class="p">)</span>

            <span class="n">intervened_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">top_sort</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sdct</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">component</span><span class="p">))</span>
                <span class="n">parent_nodes</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">parent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;orienting component </span><span class="si">{component}</span><span class="s2">, parent=</span><span class="si">{parent}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">component_intervened_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verification_optimal_helper</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">parent_nodes</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;intervened: </span><span class="si">{component_intervened_nodes}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">intervened_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">component_intervened_nodes</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">intervened_nodes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cpdag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpdag</span><span class="p">()</span> <span class="k">if</span> <span class="n">cpdag</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cpdag</span>
            <span class="n">node2oriented</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">node</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">interventional_cpdag</span><span class="p">([{</span><span class="n">node</span><span class="p">}],</span> <span class="n">cpdag</span><span class="o">=</span><span class="n">cpdag</span><span class="p">)</span><span class="o">.</span><span class="n">arcs</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">-</span> <span class="n">cpdag</span><span class="o">.</span><span class="n">dominated_nodes</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">core_utils</span><span class="o">.</span><span class="n">powerset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">-</span> <span class="n">cpdag</span><span class="o">.</span><span class="n">dominated_nodes</span><span class="p">,</span> <span class="n">r_min</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">oriented</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">node2oriented</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ss</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">oriented</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cpdag</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">cpdag</span><span class="o">.</span><span class="n">arcs</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">ss</span></div>

<div class="viewcode-block" id="DAG.greedy_optimal_single_node_intervention"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.greedy_optimal_single_node_intervention.html#causaldag.classes.dag.DAG.greedy_optimal_single_node_intervention">[docs]</a>    <span class="k">def</span> <span class="nf">greedy_optimal_single_node_intervention</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cpdag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_interventions</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Greedily pick ``num_interventions`` single node interventions based on how many edges they orient.</span>

<span class="sd">        By submodularity, this will orient at least (1 - 1/e) as many edges as the optimal intervention set</span>
<span class="sd">        of size ``num_interventions``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cpdag:</span>
<span class="sd">            the starting CPDAG containing known orientations. If None, use the observational essential graph.</span>
<span class="sd">        num_interventions:</span>
<span class="sd">            the number of single-node interventions used. Default is 1.</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        (interventions, cpdags)</span>
<span class="sd">            The selected interventions and the associated cpdags that they induce.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG(arcs={(0, 1), (1, 2), (0, 2)})</span>
<span class="sd">        &gt;&gt;&gt; ivs, icpdags = d.greedy_optimal_single_node_intervention()</span>
<span class="sd">        &gt;&gt;&gt; ivs</span>
<span class="sd">        [1]</span>
<span class="sd">        &gt;&gt;&gt; icpdags[0].arcs</span>
<span class="sd">        {(0, 1), (0, 2), (1, 2)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="k">if</span> <span class="n">cpdag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cpdag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpdag</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cpdag</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_interventions</span><span class="p">,</span> <span class="p">[</span><span class="n">cpdag</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_interventions</span>

        <span class="n">nodes2icpdags</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">node</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">interventional_cpdag</span><span class="p">([{</span><span class="n">node</span><span class="p">}],</span> <span class="n">cpdag</span><span class="o">=</span><span class="n">cpdag</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">-</span> <span class="n">cpdag</span><span class="o">.</span><span class="n">dominated_nodes</span>
        <span class="p">}</span>
        <span class="n">nodes2num_oriented</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">node</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">icpdag</span><span class="o">.</span><span class="n">_arcs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">icpdag</span> <span class="ow">in</span> <span class="n">nodes2icpdags</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="n">best_iv</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nodes2num_oriented</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">op</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">icpdag</span> <span class="o">=</span> <span class="n">nodes2icpdags</span><span class="p">[</span><span class="n">best_iv</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">num_interventions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">best_iv</span><span class="p">],</span> <span class="p">[</span><span class="n">icpdag</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">best_ivs</span><span class="p">,</span> <span class="n">icpdags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">greedy_optimal_single_node_intervention</span><span class="p">(</span><span class="n">cpdag</span><span class="o">=</span><span class="n">icpdag</span><span class="p">,</span>
                                                                             <span class="n">num_interventions</span><span class="o">=</span><span class="n">num_interventions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">best_iv</span><span class="p">]</span> <span class="o">+</span> <span class="n">best_ivs</span><span class="p">,</span> <span class="p">[</span><span class="n">icpdag</span><span class="p">]</span> <span class="o">+</span> <span class="n">icpdags</span></div>

<div class="viewcode-block" id="DAG.greedy_optimal_fully_orienting_interventions"><a class="viewcode-back" href="../../../classes/generated/causaldag.classes.dag.DAG.greedy_optimal_fully_orienting_interventions.html#causaldag.classes.dag.DAG.greedy_optimal_fully_orienting_interventions">[docs]</a>    <span class="k">def</span> <span class="nf">greedy_optimal_fully_orienting_interventions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cpdag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find a set of interventions which fully orients a CPDAG into this DAG, using greedy selection of the</span>
<span class="sd">        interventions. By submodularity, the number of interventions is a (1 + ln K) multiplicative approximation</span>
<span class="sd">        to the true optimal number of interventions, where K is the number of undirected edges in the CPDAG.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cpdag</span>
<span class="sd">            the starting CPDAG containing known orientations. If None, use the observational essential graph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (interventions, cpdags)</span>
<span class="sd">            The selected interventions and the associated cpdags that they induce.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import causaldag as cd</span>
<span class="sd">        &gt;&gt;&gt; d = cd.DAG(arcs={(0, 1), (1, 2), (0, 2), (0, 3), (1, 3), (2, 3)})</span>
<span class="sd">        &gt;&gt;&gt; ivs, icpdags = d.greedy_optimal_fully_orienting_interventions()</span>
<span class="sd">        &gt;&gt;&gt; ivs</span>
<span class="sd">        [1, 2]</span>
<span class="sd">        &gt;&gt;&gt; icpdags[0].edges</span>
<span class="sd">        {frozenset({2, 3})}</span>
<span class="sd">        &gt;&gt;&gt; icpdags[1].edges</span>
<span class="sd">        set()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_untested</span><span class="p">()</span>  <span class="c1"># TODO: ADD TEST</span>

        <span class="k">if</span> <span class="n">cpdag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">cpdag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpdag</span><span class="p">()</span>
        <span class="n">curr_cpdag</span> <span class="o">=</span> <span class="n">cpdag</span>
        <span class="n">ivs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">icpdags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_cpdag</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">iv</span><span class="p">,</span> <span class="n">icpdag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">greedy_optimal_single_node_intervention</span><span class="p">(</span><span class="n">cpdag</span><span class="o">=</span><span class="n">curr_cpdag</span><span class="p">)</span>
            <span class="n">iv</span> <span class="o">=</span> <span class="n">iv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">icpdag</span> <span class="o">=</span> <span class="n">icpdag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">curr_cpdag</span> <span class="o">=</span> <span class="n">icpdag</span>
            <span class="n">ivs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
            <span class="n">icpdags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">icpdag</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ivs</span><span class="p">,</span> <span class="n">icpdags</span></div>

    <span class="k">def</span> <span class="nf">_verification_optimal_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span> <span class="n">parent_component</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="c1"># for a clique, select every other node</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;component is clique&#39;</span><span class="p">)</span>
            <span class="n">residual</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">component</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">parent_component</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;residual: </span><span class="si">{residual}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sorted_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">induced_subgraph</span><span class="p">(</span><span class="n">residual</span><span class="p">)</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">()</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">sorted_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sorted_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">induced_subgraph</span><span class="p">(</span><span class="nb">frozenset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">component</span><span class="p">))</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">()</span>

            <span class="c1"># determine common head</span>
            <span class="n">intersections</span> <span class="o">=</span> <span class="p">[</span><span class="n">c1</span> <span class="o">&amp;</span> <span class="n">c2</span> <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">itr</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
            <span class="n">common_head</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">intersections</span><span class="p">)</span> <span class="o">-</span> <span class="n">parent_component</span>
            <span class="n">max_intersection</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">intersections</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
            <span class="c1"># if max_intersection != frozenset.union(*intersections):</span>
            <span class="c1">#     raise RuntimeError</span>
            <span class="n">sorted_common_head</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">sorted_nodes</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">common_head</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;component contains multiple cliques, common head = </span><span class="si">{sorted_common_head}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># determine heads and tails</span>
            <span class="n">heads</span> <span class="o">=</span> <span class="p">[</span><span class="n">clique</span> <span class="o">&amp;</span> <span class="n">common_head</span> <span class="k">for</span> <span class="n">clique</span> <span class="ow">in</span> <span class="n">component</span><span class="p">]</span>
            <span class="n">tails</span> <span class="o">=</span> <span class="p">[</span><span class="n">clique</span> <span class="o">-</span> <span class="n">common_head</span> <span class="o">-</span> <span class="n">parent_component</span> <span class="k">for</span> <span class="n">clique</span> <span class="ow">in</span> <span class="n">component</span><span class="p">]</span>
            <span class="n">sorted_heads</span> <span class="o">=</span> <span class="p">[[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">sorted_nodes</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">head</span><span class="p">]</span> <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">heads</span><span class="p">]</span>
            <span class="n">sorted_tails</span> <span class="o">=</span> <span class="p">[[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">sorted_nodes</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tail</span><span class="p">]</span> <span class="k">for</span> <span class="n">tail</span> <span class="ow">in</span> <span class="n">tails</span><span class="p">]</span>

            <span class="c1"># add nodes from tails</span>
            <span class="n">intervened_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sorted_heads</span><span class="p">,</span> <span class="n">sorted_tails</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;tail=</span><span class="si">{tail}</span><span class="s2">, head=</span><span class="si">{head}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">intervened_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tail</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">intervened_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">head</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># add remaining nodes from common head</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">sorted_common_head</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">intervened_nodes</span><span class="p">:</span>
                    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">counter</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">intervened_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">return</span> <span class="n">intervened_nodes</span>
            <span class="c1"># TODO: test!</span>

    <span class="c1"># === ADJUSTMENT SETS</span>
    <span class="k">def</span> <span class="nf">backdoor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a set of nodes S satisfying the backdoor criterion if such an S exists, otherwise False.</span>

<span class="sd">        S satisfies the backdoor criterion if</span>
<span class="sd">        (i) S blocks every path from i to j with an arrow into i</span>
<span class="sd">        (ii) no node in S is a descendant of i</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">frontdoor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a set of nodes S satisfying the frontdoor criterion if such an S exists, otherwise False.</span>

<span class="sd">        S satisfies the frontdoor criterion if</span>
<span class="sd">        (i) S blocks all directed paths from i to j</span>
<span class="sd">        (ii) there are no unblocked backdoor paths from i to S</span>
<span class="sd">        (iii) i blocks all backdoor paths from S to j</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="n">arcs</span><span class="o">=</span><span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)})</span>
    <span class="n">d</span><span class="o">.</span><span class="n">save_gml</span><span class="p">(</span><span class="s1">&#39;test_mine.gml&#39;</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, Chandler Squires.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>